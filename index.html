<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¬¼ë•Œ & ì¡°ë¥˜ ì •ë³´</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; connect-src 'self' https://tide-api-proxy.odk297.workers.dev; img-src 'self' data:;">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js" integrity="sha384-vsrfeLOOY6KuIYKDlmVH5UiBmgIdB1oEf7p01YgWHuqmOHfZr374+odEv96n9tNC" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0/dist/chartjs-plugin-annotation.min.js" integrity="sha384-3N9GHhCtN3CQef6tNfqgZlv7sQLYIkcChN+uaTZ7xVdzKYp/SjBNPxa92+hM7EAY" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/korean-lunar-calendar/dist/korean-lunar-calendar.min.js" integrity="sha384-j2B3PtxdEJouApN6GZLZXajab489KytFYmY/gDo6Dp3afstT7oZmYu0YvIik1OoV" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #0a1628;
            --card: #111d35;
            --border: #1e3a5f;
            --primary: #4fc3f7;
            --accent: #00e5ff;
            --high: #ff6b6b;
            --low: #4ecdc4;
            --text: #e0e6ed;
            --muted: #7a8ba3;
            --warn: #ffa726;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'Segoe UI', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        .container { max-width: 960px; margin: 0 auto; padding: 16px; }
        header { text-align: center; padding: 20px 0 12px; }
        header h1 { font-size: 1.6em; color: var(--accent); display: flex; align-items: center; justify-content: center; gap: 10px; }
        header h1 .wave { font-size: 1.3em; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px; align-items: flex-end; }
        .control-group { flex: 1; min-width: 140px; }
        .control-group label { display: block; font-size: 0.78em; color: var(--muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        select, input[type="date"] { width: 100%; padding: 10px 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; color: var(--text); font-size: 0.95em; font-family: 'Segoe UI', -apple-system, sans-serif; outline: none; cursor: pointer; }
        input[type="date"] { position: relative; color-scheme: dark; }
        input[type="date"]::-webkit-datetime-edit { color: var(--text); font-family: 'Segoe UI', -apple-system, sans-serif; width: 100%; text-align: center; padding: 0; margin: auto; }
        input[type="date"]::-webkit-calendar-picker-indicator { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        select:focus, input:focus { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(79,195,247,0.2); }
        .btn { padding: 10px 24px; background: linear-gradient(135deg, #1a73e8, #4fc3f7); border: none; border-radius: 8px; color: #fff; font-size: 0.95em; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(79,195,247,0.3); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 16px; }
        .card-title { font-size: 1em; color: var(--primary); margin-bottom: 14px; display: flex; align-items: center; gap: 8px; font-weight: 600; }
        .chart-title-row { display: flex; align-items: center; width: 100%; gap: 8px; }
        .tide-chart-load-status { margin-left: auto; display: inline-flex; align-items: center; gap: 6px; font-size: 0.72em; color: var(--muted); }
        .tide-chart-load-status.is-loading .tide-chart-load-text { color: #ffb74d; }
        .tide-chart-load-status.is-done .tide-chart-load-text { color: #69f0ae; }
        .tide-chart-load-status.is-error .tide-chart-load-text { color: var(--high); }
        .tide-chart-reload-btn {
            width: 20px;
            height: 20px;
            border: 1px solid var(--border);
            border-radius: 50%;
            background: rgba(255,255,255,0.03);
            color: var(--primary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95em;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
        }
        .tide-chart-reload-btn:hover { background: rgba(79,195,247,0.14); }
        .tide-chart-reload-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .tide-chart-reload-btn.is-spinning { animation: spin 0.8s linear infinite; }
        .tide-data-stamp { margin-top: -8px; margin-bottom: 10px; font-size: 0.72em; color: var(--muted); letter-spacing: 0.02em; }
        .tide-summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; }
        .tide-item { background: rgba(255,255,255,0.03); border-radius: 10px; padding: 14px; text-align: center; border: 1px solid rgba(255,255,255,0.05); }
        .tide-item.high { border-left: 3px solid var(--high); }
        .tide-item.low { border-left: 3px solid var(--low); }
        .tide-item.diff { border-left: 3px solid var(--warn); }
        .tide-item .label { font-size: 0.85em; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .tide-item .value { font-size: 1.8em; font-weight: 700; margin: 4px 0; }
        .tide-item.high .value { color: var(--high); }
        .tide-item.low .value { color: var(--low); }
        .tide-item.diff .value { color: var(--warn); }
        .tide-item .time { font-size: 0.92em; color: var(--muted); }
        .chart-container { position: relative; height: 320px; }
        .current-table { width: 100%; border-collapse: collapse; }
        .current-table th { text-align: left; padding: 8px 12px; font-size: 0.78em; color: var(--muted); text-transform: uppercase; border-bottom: 1px solid var(--border); }
        .current-table td { padding: 10px 12px; font-size: 0.9em; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .current-table th.current-speed-col,
        .current-table td.current-speed-col {
            width: 120px;
            white-space: nowrap;
        }
        .current-table td.current-dir-col,
        .current-table td.current-speed-col {
            font-size: 0.9em;
        }
        .current-table th.current-speed-col { text-align: center; }
        .current-table td.current-speed-col {
            text-align: center;
            padding-left: 12px;
            padding-right: 12px;
        }
        .current-unit-toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: rgba(79,195,247,0.08);
            color: var(--primary);
            font-size: inherit;
            font-weight: 600;
            text-transform: none;
            padding: 2px 6px;
            cursor: pointer;
            line-height: 1;
            transition: all 0.2s;
        }
        .current-unit-toggle-btn:hover { background: rgba(79,195,247,0.18); border-color: #2a6fa3; }
        .current-unit-toggle-btn:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(79,195,247,0.35); }
        .current-unit-toggle-btn .unit-icon { font-size: 0.85em; opacity: 0.95; }
        .current-unit-toggle-btn .unit-hint { font-size: 0.72em; color: var(--muted); font-weight: 600; }
        .speed-bar { height: 6px; border-radius: 3px; background: var(--border); overflow: hidden; margin-top: 4px; }
        .speed-bar-fill { height: 100%; border-radius: 3px; transition: width 0.5s; }
        .loading { text-align: center; padding: 40px; color: var(--muted); }
        .loading .spinner { display: inline-block; width: 32px; height: 32px; border: 3px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .error-msg { color: var(--high); text-align: center; padding: 20px; font-size: 0.9em; }
        .tide-detail-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .tide-tag { padding: 6px 14px; border-radius: 20px; font-size: 0.82em; font-weight: 500; }
        .tide-tag.high { background: rgba(255,107,107,0.15); color: var(--high); }
        .tide-tag.low { background: rgba(78,205,196,0.15); color: var(--low); }
        .tide-item.sun { border-left: 3px solid #ffb74d; }
        .sun-row { display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 1.05em; }
        .sun-row .sun-time { color: #ffb74d; font-weight: 700; font-size: 1.15em; }
        .sun-row .sun-label { color: var(--muted); font-size: 0.85em; }
        footer { text-align: center; padding: 20px; color: var(--muted); font-size: 0.75em; }
        .tabs { display: flex; gap: 4px; margin-bottom: 16px; border-bottom: 1px solid var(--border); }
        .tab-btn { padding: 10px 20px; background: transparent; border: none; color: var(--muted); font-size: 0.9em; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }
        .tab-btn:hover { color: var(--text); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* ê²€ìƒ‰ ë°” */
        .search-bar { position: relative; margin-bottom: 16px; }
        .search-bar input { width: 100%; padding: 12px 16px 12px 40px; background: var(--card); border: 1px solid var(--border); border-radius: 10px; color: var(--text); font-size: 0.95em; outline: none; }
        .search-bar:focus-within { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(79,195,247,0.2); }
        .search-bar input:focus { outline: none; box-shadow: none; }
        .search-bar .search-icon { position: absolute; left: 14px; top: 50%; transform: translateY(-50%); font-size: 1em; color: var(--muted); pointer-events: none; }
        .search-results { position: absolute; top: 100%; left: 0; right: 0; background: var(--card); border: 1px solid var(--border); border-radius: 10px; max-height: 320px; overflow-y: auto; z-index: 100; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.4); margin-top: 4px; }
        .search-results.show { display: block; }
        .search-result-item { padding: 10px 16px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .search-result-item:hover { background: rgba(79,195,247,0.1); }
        .search-result-item:last-child { border-bottom: none; }
        .search-result-item .name { color: var(--text); font-size: 0.9em; }
        .search-result-item .name em { color: var(--accent); font-style: normal; font-weight: 600; }
        .search-result-item .tags { display: flex; gap: 4px; }
        .search-result-item .tag { padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 500; }
        .search-result-item .tag.obs { background: rgba(79,195,247,0.15); color: var(--primary); }
        .search-result-item .tag.crnt { background: rgba(0,229,255,0.15); color: var(--accent); }
        .search-result-item .tag.region { background: rgba(255,167,38,0.15); color: var(--warn); }
        .search-no-result { padding: 16px; text-align: center; color: var(--muted); font-size: 0.85em; }
        .region-badge { display: inline-block; padding: 2px 10px; border-radius: 10px; font-size: 0.72em; background: rgba(79,195,247,0.12); color: var(--primary); margin-left: 8px; vertical-align: middle; }
        .mulddae-card { display: flex; flex-direction: column; gap: 8px; }
        .mulddae-row1 { display: flex; align-items: center; gap: 10px; }
        .mulddae-badge { display: flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 12px; font-weight: 700; flex-shrink: 0; }
        .mulddae-badge .mulddae-emoji { font-size: 1.3em; line-height: 1; }
        .mulddae-badge .mulddae-moon { width: 1.86em; height: 1.86em; border-radius: 50%; flex-shrink: 0; object-fit: cover; }
        .mulddae-badge .mulddae-num { font-size: 1.1em; }
        .mulddae-pct-wrap { display: flex; flex-direction: column; align-items: stretch; gap: 4px; flex: 1; min-width: 0; }
        .mulddae-pct-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
        .mulddae-pct-value-wrap { display: inline-flex; align-items: baseline; gap: 6px; flex-shrink: 0; }
        .mulddae-pct-label-inline { color: var(--muted); font-size: 0.82em; }
        .mulddae-pct-value { font-weight: 700; font-size: 0.95em; }
        .mulddae-pct-bar { display: block; width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; }
        .mulddae-pct-bar-fill { height: 100%; border-radius: 4px; }
        .mulddae-desc { font-size: 0.85em; color: var(--muted); }
        .mulddae-species { display: flex; gap: 6px; flex-wrap: wrap; }

        @media (max-width: 600px) {
            .controls { flex-direction: column; }
            .control-group { min-width: 100%; }
            .chart-container { height: 260px; }
            .tide-summary { grid-template-columns: repeat(3, 1fr); gap: 8px; }
            header h1 { font-size: 1.3em; }
            .mulddae-card { gap: 6px; }
            .mulddae-row1 { flex-wrap: wrap; gap: 8px; }
            .species-btns { flex-wrap: wrap !important; }
            .card-title { flex-wrap: wrap; }
        }
        @media (max-width: 480px) {
            .container { padding: 10px; }
            header { padding: 12px 0 8px; }
            header h1 { font-size: 1.15em; }
            .card { padding: 14px; margin-bottom: 12px; }
            .card-title { font-size: 0.9em; margin-bottom: 10px; }
            .tide-summary { grid-template-columns: repeat(3, 1fr); gap: 6px; }
            .tide-item { padding: 10px 4px; }
            .tide-item .value { font-size: 1.3em; }
            .tide-item .label { font-size: 0.7em; }
            .tide-item .time { font-size: 0.78em; }
            .chart-container { height: 240px; }
            .species-btn { font-size: 0.7em !important; padding: 3px 8px !important; }
            .mulddae-card { gap: 5px; }
            .mulddae-badge { padding: 5px 10px; }
            .mulddae-badge .mulddae-emoji { font-size: 1.1em; }
            .mulddae-badge .mulddae-moon { width: 1.56em; height: 1.56em; }
            .mulddae-badge .mulddae-num { font-size: 1em; }
            .mulddae-desc { font-size: 0.8em; }
            .mulddae-pct-label-inline { font-size: 0.76em; }
            .tide-data-stamp { font-size: 0.68em; }
            .tab-btn { padding: 8px 14px; font-size: 0.85em; }
            .btn { padding: 8px 16px; font-size: 0.88em; }
            .sun-row { font-size: 0.9em; }
            .sun-row .sun-time { font-size: 1em; }
            .current-unit-toggle-btn .unit-hint { display: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><span class="wave">ğŸŒŠ</span> ë¬¼ë•Œ & ì¡°ë¥˜ ì •ë³´</h1>
        </header>

        <!-- Controls -->
        <div class="controls">
            <div class="control-group" style="display:flex;gap:8px;flex-wrap:nowrap;align-items:flex-end;">
                <div style="flex:1;min-width:0;">
                    <label>ê´€ì¸¡ì†Œ (ì¡°ìœ„) <span class="region-badge" id="stationRegion">ì¸ì²œ/ê²½ê¸°</span></label>
                    <select id="stationSelect"></select>
                </div>
                <div style="flex:1;min-width:0;">
                    <label>ì¡°ë¥˜ ì˜ˆë³´ì  <span class="region-badge" id="currentRegion">ì¸ì²œ/ê²½ê¸°</span></label>
                    <select id="currentSelect"></select>
                </div>
            </div>
        </div>

        <!-- ê²€ìƒ‰ -->
        <div class="search-bar" id="searchBar" style="display:flex;align-items:center;gap:0;background:var(--card);border:1px solid var(--border);border-radius:10px;padding:0;cursor:text;" onclick="focusAndClearSearchInput(event)">
            <span class="search-icon" style="position:static;transform:none;padding-left:14px;flex-shrink:0;">ğŸ”</span>
            <input type="text" id="searchInput" placeholder="&#xAC80;&#xC0C9;" autocomplete="off" style="flex:1;min-width:60px;background:transparent;border:none;padding:12px 8px 12px 8px;" />
            <span id="searchPortInfo" style="display:none;font-size:0.78em;color:var(--muted);white-space:nowrap;padding-right:12px;flex-shrink:0;">â†’ ì¡°ìœ„: <strong id="searchPortStation" style="color:var(--primary)"></strong> Â· ì¡°ë¥˜: <strong id="searchPortCurrent" style="color:var(--accent)"></strong></span>
            <div class="search-results" id="searchResults"></div>
        </div>

        <!-- ë‚ ì§œ ì»¨íŠ¸ë¡¤ -->
        <div class="controls" style="margin-top:0;">
            <div class="control-group">
                <div style="display:flex;align-items:flex-end;gap:4px;">
                    <div style="display:flex;flex-direction:column;align-items:center;gap:2px;">
                        <span style="font-size:0.85em;color:var(--muted);">ì›”</span>
                        <div style="display:flex;gap:4px;align-items:stretch;">
                            <button class="btn" style="padding:0 10px;font-size:0.9em;min-width:0;height:36px;" onclick="shiftMonth(-1)">â—€</button>
                            <button class="btn" style="padding:0 10px;font-size:0.9em;min-width:0;height:36px;" onclick="shiftMonth(1)">â–¶</button>
                        </div>
                    </div>
                    <div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:2px;min-width:0;">
                        <span style="font-size:0.85em;color:var(--muted);">ë‚ ì§œ</span>
                        <div style="position:relative;width:100%;height:36px;">
                            <input type="date" id="dateInput" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;z-index:2;" />
                            <div id="dateDisplay" onclick="document.getElementById('dateInput').showPicker?document.getElementById('dateInput').showPicker():document.getElementById('dateInput').focus()" style="width:100%;height:36px;line-height:36px;background:var(--card);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:1em;text-align:center;cursor:pointer;position:relative;z-index:1;box-sizing:border-box;">2026ë…„ 02ì›” 15ì¼</div>
                        </div>
                    </div>
                    <div style="display:flex;flex-direction:column;align-items:center;gap:2px;">
                        <span style="font-size:0.85em;color:var(--muted);">ì¼</span>
                        <div style="display:flex;gap:4px;align-items:stretch;">
                            <button class="btn" style="padding:0 10px;font-size:0.9em;min-width:0;height:36px;" onclick="shiftDay(-1)">â—€</button>
                            <button class="btn" style="padding:0 10px;font-size:0.9em;min-width:0;height:36px;" onclick="shiftDay(1)">â–¶</button>
                        </div>
                    </div>
                    <button class="btn" id="searchBtn" style="padding:0 12px;font-size:0.9em;min-width:0;height:36px;align-self:flex-end;" onclick="fetchAll()">ì¡°íšŒ</button>
                </div>
            </div>
        </div>

        <!-- ë‚šì‹œ í¬ì¸íŠ¸ ì—°ê²° í‘œì‹œ ë°°ë„ˆ -->
        <div id="portBanner" style="display:none; margin-bottom:12px; padding:10px 16px; background:rgba(0,229,255,0.08); border:1px solid rgba(0,229,255,0.2); border-radius:10px; font-size:0.85em;">
            <span style="color:var(--accent);">ğŸ“ <strong id="portBannerName"></strong></span>
            <span style="color:var(--muted);margin-left:8px;">â†’ ì¡°ìœ„: <strong id="portBannerStation" style="color:var(--primary)"></strong> Â· ì¡°ë¥˜: <strong id="portBannerCurrent" style="color:var(--accent)"></strong></span>
            <span id="portBannerClose" style="float:right;cursor:pointer;color:var(--muted);font-size:1.1em;" title="ë‹«ê¸°">âœ•</span>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="tide">ë¬¼ë•Œ/ì¡°ìœ„</button>
            <button class="tab-btn" data-tab="current">ì¡°ë¥˜ ìœ ì†</button>
            <button class="tab-btn" data-tab="combined">ì¡°ìœ„-ìœ ì† ê·¸ë˜í”„</button>
        </div>

        <!-- Tide Tab -->
        <div class="tab-content active" id="tab-tide">
            <div class="card" id="mulddaeCard" style="display:none;">
                <div class="card-title" style="flex-wrap:wrap;gap:6px;align-items:center;">ì˜¤ëŠ˜ì˜ ë¬¼ë•Œ <span id="mulddaeDate" style="font-weight:600;color:var(--text);font-size:0.88em;"></span></div>
                <div id="mulddaeInfo" class="mulddae-card"></div>
                <div id="mulddaeSpeciesInfo" style="display:none;margin-top:10px;"></div>
            </div>
            <div class="card" id="tideSummaryCard">
                <div class="card-title">ğŸ“Š ê³ ì €ì¡° ì •ë³´</div>
                <div id="tideDataStamp" class="tide-data-stamp">ì˜ˆë³´ ìƒì„±ì‹œê° - Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° -</div>
                <div id="tideSummary"><div style="text-align:center;color:var(--muted);padding:20px;">ê´€ì¸¡ì†Œì™€ ë‚ ì§œë¥¼ ì„ íƒ í›„ ì¡°íšŒí•˜ì„¸ìš”</div></div>
            </div>
            <div class="card">
                <div class="card-title" style="flex-wrap:wrap;gap:8px;">
                    <div class="chart-title-row">
                        <span>ğŸ“ˆ ì¡°ìœ„ ë³€í™” ê·¸ë˜í”„</span>
                        <div id="tideChartLoadStatus" class="tide-chart-load-status">
                            <span id="tideChartLoadText" class="tide-chart-load-text">ëŒ€ê¸°</span>
                            <button type="button" id="tideChartReloadBtn" class="tide-chart-reload-btn" onclick="refreshTideChart()" aria-label="ì¡°ìœ„ ê·¸ë˜í”„ ìƒˆë¡œê³ ì¹¨" title="ì¡°ìœ„ ê·¸ë˜í”„ ìƒˆë¡œê³ ì¹¨">â†»</button>
                        </div>
                    </div>
                </div>
                <div class="species-btns" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px;">
                    <button class="species-btn" data-species="none" onclick="toggleSpecies('none')" style="padding:4px 12px;border-radius:16px;border:1px solid var(--border);background:transparent;color:var(--muted);font-size:0.78em;cursor:pointer;transition:all 0.2s;">ì–´ì¢… OFF</button>
                    <button class="species-btn" data-species="jjukkumi" onclick="toggleSpecies('jjukkumi')" style="padding:4px 12px;border-radius:16px;border:1px solid var(--border);background:transparent;color:var(--muted);font-size:0.78em;cursor:pointer;transition:all 0.2s;">ğŸ™ ì­ˆê¾¸ë¯¸</button>
                    <button class="species-btn" data-species="gapoh" onclick="toggleSpecies('gapoh')" style="padding:4px 12px;border-radius:16px;border:1px solid var(--border);background:transparent;color:var(--muted);font-size:0.78em;cursor:pointer;transition:all 0.2s;">ğŸ¦‘ ê°‘ì˜¤ì§•ì–´</button>
                    <button class="species-btn" data-species="muneo" onclick="toggleSpecies('muneo')" style="padding:4px 12px;border-radius:16px;border:1px solid var(--border);background:transparent;color:var(--muted);font-size:0.78em;cursor:pointer;transition:all 0.2s;">ğŸ™ ë¬¸ì–´</button>
                </div>
                <div id="speciesLegend" style="display:none;margin-bottom:10px;padding:8px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:0.8em;color:var(--muted);line-height:1.6;"></div>
                <div id="tideLegend" style="display:none;margin-bottom:6px;font-size:0.75em;color:var(--muted);align-items:center;gap:10px;flex-wrap:wrap;"></div>
                <div id="chartSlackInfo" style="display:none;font-size:0.65em;margin-bottom:4px;color:var(--muted);gap:4px;flex-wrap:wrap;align-items:center;letter-spacing:0.03em;"></div>
                <div class="chart-container"><canvas id="tideChart"></canvas></div>
            </div>
        </div>

        <!-- Current Tab -->
        <div class="tab-content" id="tab-current">
            <div class="card">
                <div class="card-title">ğŸŒ€ ì¡°ë¥˜ ì •ë³´ (ìœ í–¥/ìœ ì†)</div>
                <div id="currentInfo"><div style="text-align:center;color:var(--muted);padding:20px;">ì¡°ë¥˜ ì˜ˆë³´ì ê³¼ ë‚ ì§œë¥¼ ì„ íƒ í›„ ì¡°íšŒí•˜ì„¸ìš”</div></div>
            </div>
            <div class="card">
                <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;">
                    <span>ğŸ“ˆ ì¡°ë¥˜ ìœ ì† ê·¸ë˜í”„</span>
                    <button type="button" class="current-unit-toggle-btn" onclick="toggleCurrentSpeedUnit()" title="í´ë¦­í•´ì„œ cm/sì™€ k/n ë‹¨ìœ„ë¥¼ ì „í™˜" aria-label="ìœ ì† ë‹¨ìœ„ ì „í™˜"><span id="chartSpeedUnitLabel">ìœ ì† (cm/s)</span><span class="unit-icon">â‡„</span><span class="unit-hint">í´ë¦­ ì „í™˜</span></button>
                </div>
                <div class="chart-container"><canvas id="currentChart"></canvas></div>
            </div>
        </div>

        <!-- Combined Tab -->
        <div class="tab-content" id="tab-combined">
            <div class="card" style="padding-bottom:12px;">
                <div class="card-title" style="margin-bottom:4px;">ğŸ“Š ì¡°ìœ„-ìœ ì† ë³µí•© ê·¸ë˜í”„</div>
                <div id="combinedChartLegend" style="display:flex;gap:14px;flex-wrap:wrap;margin-bottom:2px;padding:3px 10px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:0.76em;color:var(--muted);align-items:center;"></div>
                <div class="chart-container" style="height:380px;"><canvas id="combinedChart"></canvas></div>
                <div id="combinedChartInfo" style="margin-top:10px;font-size:0.76em;color:var(--muted);text-align:center;letter-spacing:0.02em;"></div>
            </div>
        </div>

        <footer>
            ë°ì´í„° ì¶œì²˜: êµ­ë¦½í•´ì–‘ì¡°ì‚¬ì› (ê³µê³µë°ì´í„°í¬í„¸)<br>
            â€» ì˜ˆì¸¡ ë°ì´í„°ì´ë©°, ì‹¤ì œ ê°’ê³¼ ì°¨ì´ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </footer>
    </div>

    <script>
    // ==================== CONFIG ====================
    const API_BASE = 'https://tide-api-proxy.odk297.workers.dev';
    let tideChart = null;
    let currentChart = null;
    let combinedChart = null;
    let tideChartReloading = false;
    let currentSpeedUnit = 'cm/s';
    let currentViewState = { items: [], el: null, fldEbbSummary: null, areaSummary: null };
    const CMPS_PER_KNOT = 51.444444;

    // ==================== ì§€ì—­ ë°ì´í„° (ê´€ì¸¡ì†Œ + ì¡°ë¥˜ ì˜ˆë³´ì  í†µí•©) ====================
    const REGIONS = [
        {
            key: 'incheon', label: 'ì¸ì²œ/ê²½ê¸°',
            stations: [
                ['DT_0001','ì¸ì²œ'],['DT_0052','ì¸ì²œì†¡ë„'],['DT_0044','ì˜ì¢…ëŒ€êµ'],['DT_0032','ê°•í™”ëŒ€êµ'],
                ['DT_0043','ì˜í¥ë„'],['DT_0093','ì†Œë¬´ì˜ë„'],['DT_0065','ë•ì ë„'],['DT_0066','í–¥í™”ë„'],
                ['DT_0002','í‰íƒ'],['DT_0008','ì•ˆì‚°']
            ],
            currents: [
                ['07GG03','ì„ëª¨ìˆ˜ë„'],['07GG06','ì¸ì²œê°‘ë¬¸'],['07GG11','ë•ì ë„'],['09IC01','ì¸ì²œë‚¨í•­'],
                ['09IC07','ê²½ì¸ì•„ë¼ë±ƒê¸¸'],['14IC03','ìì›”ë„ë¶ì¸¡'],['14IC04','ì´ì‘ë„ì„œì¸¡'],['16LTC01','ì¸ì²œëŒ€êµ'],
                ['16LTC02','ì¸ì²œë™ìˆ˜ë„ì…êµ¬'],['16DJ04','ì‹œí™”ë°©ì¡°ì œ'],['17LTC01','ì¸ì²œì‹ í•­ì…êµ¬'],['17LTC02','ê²½ê¸°ë§Œë¶ìˆ˜ë„'],
                ['19LTC01','í™”ì„±ë°©ì¡°ì œ'],['20LTC04','ì˜í¥ë„ì„œì¸¡'],['20LTC07','ìì›”ë„ë¶ì„œì¸¡'],['20LTC11','ë•ì êµ°ë„ì„œì¸¡'],
                ['20LTC12','ìˆ˜ìš°ë„ì„œì¸¡'],['05GH-5','ì¥ë´‰ìˆ˜ë„'],['15LTC01','ì—¼í•˜ìˆ˜ë„'],['03DS-1','ì¥ì•ˆì„œ']
            ]
        },
        {
            key: 'west_mid', label: 'ì¶©ë‚¨/ì „ë¶ (ì„œí•´ì¤‘ë¶€)',
            stations: [
                ['DT_0050','íƒœì•ˆ'],['DT_0067','ì•ˆí¥'],['DT_0017','ëŒ€ì‚°'],['DT_0025','ë³´ë ¹'],
                ['DT_0051','ì„œì²œë§ˆëŸ‰'],['DT_0024','ì¥í•­'],['DT_0018','êµ°ì‚°'],['DT_0068','ìœ„ë„'],['DT_0037','ì–´ì²­ë„']
            ],
            currents: [
                ['03PT-1','ì•„ì‚°ë§Œì…êµ¬'],['07DS02','ëŒ€ì‚°í•­'],['07TA03','íƒœì•ˆ'],['07TA04','ë§Œë¦¬í¬'],
                ['07TA05','ì•ˆí¥'],['07TA09','ê²©ë ¬ë¹„ì—´ë„'],['07KS01','ì›ì‚°ë„'],['07KS03','ì™¸ì—°ì—´ë„'],
                ['12JB11','ë¹„ì¸ë§Œ'],['12JB14','êµ°ì‚°í•­ì…êµ¬'],['13PT01','í‰íƒí•­'],['15LTC08','ì¥ê³ ë„ìˆ˜ë„'],
                ['16LTC03','ì²œìˆ˜ë§Œ'],['17LTC04','ë¬¸ê°‘ë„ë™ì¸¡'],['17LTC06','ê°€ë¡œë¦¼ë§Œì…êµ¬'],['19LTC02','ì™¸ì—°ë„ë™ì¸¡'],
                ['23GA01','ì•ˆë©´ë„ì„œì¸¡'],['24TJ02','ê°€ë¡œë¦¼ë§Œ'],['24TJ04','ì…íŒŒë„'],['24TJ05','ì•„ì‚°ë§Œ28í˜¸ë“±ë¶€í‘œ']
            ]
        },
        {
            key: 'west_south', label: 'ì „ë‚¨ì„œë¶€ (ëª©í¬/ì‹ ì•ˆ)',
            stations: [
                ['DT_0007','ëª©í¬'],['DT_0035','í‘ì‚°ë„'],['DT_0094','ì„œê±°ì°¨ë„']
            ],
            currents: [
                ['01MP-2','ëª©í¬êµ¬'],['06SA01','ë©´ë„ìˆ˜ë„'],['06SA10','íŒ”êµ¬í¬ë¶ì¸¡'],['06SA18','ê²½ì¹˜ë™ìˆ˜ë„'],
                ['06GS07','ê³ êµ°ì‚°êµ°ë„'],['07JB12','ìˆ˜ë„ìˆ˜ë„ë¶ì¸¡'],['07JB14','ìˆ˜ë„ìˆ˜ë„'],['10MP07','ì‹œì•„í•´'],
                ['14BP01','ë³‘í’ë„ë¶ì¸¡'],['15LTC02','ì–´ì²­ë„ì„œì¸¡'],['15LTC03','ìœ„ë„ë™ì¸¡'],['16LTC05','ëª©í¬ë¶í•­ë¶ì¸¡'],
                ['16LTC06','ì‹œì•„í•´ë¶ì¸¡'],['17LTC08','ë…¹ë„ë¶ì¸¡'],['17LTC09','ì‹­ì´ë™íŒŒë„'],['17LTC10','ê³ êµ°ì‚°êµ°ë„ë¶ì¸¡'],
                ['17MTC14','ìœ„ë„ì„œì¸¡'],['17MTC19','ì•ˆë§ˆë„ì„œì¸¡'],['17MTC20','ì•ˆë§ˆë„ë™ì¸¡'],['18LTC01','ë‚œì§€ë„ë¶ì¸¡'],
                ['18LTC02','ì™€ë„ì„œì¸¡'],['18LTC03','ì•ˆì¢Œë„ë¶ì¸¡'],['18LTC04','ë¹„ê¸ˆìˆ˜ë„'],['19LTC03','ì¬ì›ë™ìˆ˜ë„'],
                ['19LTC04','ì¦ë„ë™ì¸¡'],['19LTC05','ë§¤í™”ë„ì„œì¸¡'],['19LTC06','í•˜ì˜ìˆ˜ë„'],['20LTC01','ì–´ë¶ˆë„ì„œì¸¡'],
                ['20LTC02','ë…ê±°êµ°ë„ë¶ì¸¡'],['20LTC03','ì™¸ëª¨êµ°ë„ë‚¨ì¸¡'],['20LTC05','í•¨í‰ë§Œì…êµ¬'],['20LTC08','ìš°ì´ìˆ˜ë„'],
                ['20LTC09','ì†¡ì´ë„ë¶ì¸¡'],['22LTC12','ë§ˆëŸ‰í•­'],['22EW01','ëŒ€í™”ì‚¬ë„ì„œì¸¡'],['23LTC05','ìœ¨ë„ë¶ë™ì¸¡'],
                ['23LTC06','ëŒ€ì•¼ë„ë™ì¸¡'],['23LTC07','ìš°ì´ë„ë‚¨ì¸¡'],['23LTC08','ì¥ì‚°ë„ì„œì¸¡'],['23LTC09','ë‹¬ë¦¬ë„ì„œì¸¡'],
                ['24LTC01','ì¬ì›ë„ë‚¨ì„œì¸¡'],['24LTC02','ì–´ì˜ë„ë¶ì¸¡'],['24LTC03','ì•ˆë§ˆë„ë‚¨ì¸¡'],['24LTC04','ê±°ë¥œë„ë‚¨ì„œì¸¡'],
                ['24LTC05','ë§ë„ë‚¨ì¸¡'],['24LTC06','ì†Œíš¡ê²½ë„ë¶ì¸¡'],['24LTC07','ì‹­ì´ë™íŒŒë„ë‚¨ë™ì¸¡'],['24LTC08','ëŒ€í™”ì‚¬ë„ë‚¨ì¸¡'],
                ['24LTC09','ì‚½ì‹œë„ë¶ì¸¡'],['24LTC10','ì™¸íŒŒìˆ˜ë„ë‚¨ì¸¡'],['24LTC11','ê°€ì˜ë„ë¶ë™ì¸¡']
            ]
        },
        {
            key: 'south_west', label: 'ì „ë‚¨ë™ë¶€ (ì§„ë„/ì™„ë„/ì—¬ìˆ˜)',
            stations: [
                ['DT_0028','ì§„ë„'],['DT_0027','ì™„ë„'],['DT_0026','ê³ í¥ë°œí¬'],['DT_0092','ì—¬í˜¸í•­'],
                ['DT_0016','ì—¬ìˆ˜'],['DT_0049','ê´‘ì–‘'],['DT_0031','ê±°ë¬¸ë„']
            ],
            currents: [
                ['06JD01','ì™¸ë³‘ë„'],['06GH01','ë“ëŸ‰ë§Œì…êµ¬'],['06GH07','ê±°ê¸ˆë„ë‚¨ì¸¡'],['06YME1','ê´‘ë„ë™ì¸¡'],
                ['06YME4','ë³´ê¸¸ë„ë‚¨ì„œì¸¡'],['06YME5','ì¥ì£½ìˆ˜ë„'],['06YME6','ë§¹ê³¨ìˆ˜ë„'],['06YME8','ë§¤ë¬¼ìˆ˜ë„'],
                ['06YS03','ì‹ ê°•ìˆ˜ë„'],['06YS04','ì„œìˆ˜ë„(ì—¬ìë§Œ)'],['06YS09','ê±°ê¸ˆìˆ˜ë„'],['08GY-5','ë¬˜ë„ìˆ˜ë„'],
                ['11JD02','ì •ë“±í•´'],['11JD09','ë§ˆë¡œí•´'],['12YS08','ê´‘ì–‘í•­'],['13WD01','ì†Œì•ˆë„'],
                ['14JD03','ì •ë“±í•´ë¶ì¸¡'],['15LTC05','ë§Œì¬ë„ì„œì¸¡'],['15LTC06','ê±°ì°¨ìˆ˜ë„'],['15LTC07','ë…ê±°êµ°ë„ë™ì¸¡'],
                ['15LTC09','ê¸ˆë‹¹ìˆ˜ë„'],['15LTC10','ì—¬ìˆ˜í•´ë§Œ'],['15SE01','ë…¸ëŸ‰ìˆ˜ë„'],['15HD05','í•˜ë™í•­'],
                ['16LTC04','ì—­ë„'],['16LTC07','ì¥ì‚°ë„ë™ì¸¡'],['16LTC08','ê´‘ì–‘í•­ì œ1í•­ë¡œ'],['16LTC12','ë‚™ë™í¬'],
                ['17LTC11','ê°€ì‚¬ë„ë™ì¸¡'],['17LTC12','ì†Œì•ˆìˆ˜ë„'],['17LTC13','ì™„ë„í†µí•­ë¶„ë¦¬ëŒ€'],['18LTC05','í‘ì¼ë„ë‚¨ì¸¡'],
                ['18LTC06','ì—¬ìˆ˜í•´í˜‘'],['18LTC07','ì—¬ìˆ˜í•´ë§Œì…êµ¬'],['18MTC10','ì´ˆë„ë‚¨ì¸¡'],['19LTC07','ì²­ì‚°ë„ë™ì¸¡'],
                ['19LTC08','ëŒ€ë³‘í’ë„ì„œì¸¡'],['19LTC09','ì´ˆë„ë™ì¸¡'],['19LTC10','ì†ì£½ë„ë¶ì¸¡'],['19LTC11','ë‚˜ë¡œë„ë™ì¸¡'],
                ['19LTC12','ì—¬ìˆ˜í•´ë§Œë‚¨ì¸¡'],['19LTC13','ëŒ€ë³‘ëŒ€ë„ë™ì¸¡'],['20LTC06','ê¸ˆì˜¤ì—´ë„ë‚¨ì¸¡'],['20LTC13','ê´€ë¦¬ë„'],
                ['20LTC14','ê°€ë•ë„ë‚¨ì¸¡'],['20LTC15','ê±°ê¸ˆë„ë™ì¸¡'],['22LTC01','ì‚¼ì²œí¬-ì œì£¼í•­ë¡œ'],['22LTC02','ëŒ€ë°©ìˆ˜ë„'],
                ['22LTC03','ë…¸ëŸ‰ìˆ˜ë„ë™ì¸¡'],['22LTC04','ì™¸ìˆ˜ë„'],['22LTC05','ê¸ˆì˜¤ìˆ˜ë„'],['22LTC06','ë°±ì•¼ë„ë™ì¸¡'],
                ['22LTC07','ë°±ì•¼ìˆ˜ë„'],['22LTC08','ì™¸ë‚˜ë¡œë„ì„œì¸¡'],['22LTC09','ì†ì£½ë„ì„œì¸¡'],['22LTC10','ì†Œë¡ë„ë™ì¸¡'],
                ['22LTC13','ì²­ì‚°ë„ì„œì¸¡'],['22LTC14','í™©ì œë„ë™ì¸¡'],['22LTC15','ê´‘ì–‘í•­Aí˜¸ë“±ë¶€í‘œ'],
                ['23LTC01','ìš°ë„ë¶ì„œì¸¡'],['23LTC02','ì œì£¼ë„ì„œì¸¡'],['23LTC03','ë°±ì¼ë„ë™ì¸¡'],['23LTC04','ì–´ë£¡ë„ë¶ì¸¡'],
                ['23YG03','ì™¸ë‚˜ë¡œë„ë‚¨ì¸¡']
            ]
        },
        {
            key: 'south_east', label: 'ê²½ë‚¨ (í†µì˜/ê±°ì œ/ë¶€ì‚°)',
            stations: [
                ['DT_0061','ì‚¼ì²œí¬'],['DT_0014','í†µì˜'],['DT_0029','ê±°ì œë„'],['DT_0063','ê°€ë•ë„'],
                ['DT_0062','ë§ˆì‚°'],['DT_0056','ë¶€ì‚°í•­ì‹ í•­'],['DT_0005','ë¶€ì‚°']
            ],
            currents: [
                ['01SR-1','ì‚¬ëŸ‰ë„ë¶ì¸¡'],['08GA01','ê°ì²œí•­ì…êµ¬'],['10GD03','ê°€ë•ìˆ˜ë„'],['16LTC09','í†µì˜í•´ë§Œ'],
                ['16LTC10','ë¹„ì§„ë„ë‚¨ì¸¡'],['16LTC13','ë¶€ì‚°í•­ì…êµ¬'],['16MTC01','ë¯¸ì¡°ìˆ˜ë„'],['16MTC16','ì§€ì‹¬ë„ì„œì¸¡'],
                ['17LTC14','ìš•ì§€ë„ë¶ì¸¡'],['18LTC08','ë‘ë¯¸ë„ë¶ì¸¡'],['18LTC09','ì‚¬ëŸ‰ë„ë™ì¸¡'],['18LTC10','ê°€ì¡°ë„ìˆ˜ë„'],
                ['18LTC11','ì§„í•´ë§Œ(í†µì˜í•­ë¡œ)'],['18LTC12','ê±°ì œë„ë™ì¸¡'],['18LTC13','í•´ìš´ëŒ€'],['19LTC14','ê´‘ì•ˆë¦¬'],
                ['21LTC01','íƒœì¢…ëŒ€ë‚¨ì¸¡'],['21LTC02','ë¶í˜•ì œë„ë‚¨ì¸¡'],['21LTC03','ê°€ë•ë„ë‚¨ì„œì¸¡'],['21LTC04','ë¶€ì‚°í•­ì‹ í•­'],
                ['21LTC05','ì €ë„ì„œì¸¡'],['21LTC06','ë‚´ë„ë™ì¸¡'],['21LTC07','ì¹ ì²œë„ë¶ì„œì¸¡'],['21LTC08','ì¥ì‚¬ë„ë¶ì¸¡'],
                ['21LTC09','ìš©ì´ˆë„ë¶ì¸¡'],['21LTC10','ê²¬ë‚´ëŸ‰í•´í˜‘'],['21LTC11','ì˜¤ê³¡ë„ë¶ì¸¡'],['21LTC12','ê³¤ë¦¬ë„ë‚¨ì¸¡'],
                ['21LTC13','ì‚¬ëŸ‰ë„ë¶ë™ì¸¡'],['21LTC14','ì‹ ìˆ˜ë„ë™ì¸¡'],['98HG-1','íš¡ê°„ìˆ˜ë„']
            ]
        },
        {
            key: 'east', label: 'ë™í•´',
            stations: [
                ['DT_0020','ìš¸ì‚°'],['DT_0091','í¬í•­'],['DT_0039','ì™•ëŒì´ˆ'],['DT_0011','í›„í¬'],
                ['DT_0057','ë™í•´í•­'],['DT_0006','ë¬µí˜¸'],['DT_0012','ì†ì´ˆ'],['DT_0013','ìš¸ë¦‰ë„']
            ],
            currents: [
                ['16LTC14','ìš¸ì‚°ì‹ í•­'],['17LTC05','ìš¸ë„'],['17LTC07','ìš¸ë„ë‚¨ì¸¡'],['18LTC14','ëŒ€ì™•ì•”ë‚¨ì¸¡']
            ]
        },
        {
            key: 'jeju', label: 'ì œì£¼',
            stations: [
                ['DT_0004','ì œì£¼'],['DT_0022','ì„±ì‚°í¬'],['DT_0010','ì„œê·€í¬'],['DT_0023','ëª¨ìŠ¬í¬'],['DT_0021','ì¶”ìë„']
            ],
            currents: [
                ['02JJ-1','ì œì£¼í•­'],['08JJ03','ì„±ì‚°í¬'],['08JJ07','ì„œê·€í¬'],['08JJ13','ì• ì›”í•­ë¶ì¸¡'],
                ['08F','ì¶”ìë„ë‚¨ì„œì¸¡'],['10ED01','ì´ì–´ë„'],['22MTC03','ì œì£¼í•´í˜‘']
            ]
        },
        {
            key: 'ocean_base', label: 'í•´ì–‘ê³¼í•™ê¸°ì§€',
            stations: [
                ['DT_0042','êµë³¸ì´ˆ'],['IE_0060','ì´ì–´ë„'],['IE_0061','ì‹ ì•ˆê°€ê±°ì´ˆ'],['IE_0062','ì˜¹ì§„ì†Œì²­ì´ˆ']
            ],
            currents: []
        }
    ];

    // ==================== ë‚šì‹œ í¬ì¸íŠ¸ í”„ë¦¬ì…‹ (ê°€ì¥ ê°€ê¹Œìš´ ê´€ì¸¡ì†Œ/ì¡°ë¥˜ì˜ˆë³´ì  ë§¤í•‘) ====================
    const FISHING_PORTS = [
        { name: 'ì˜¤ì²œí•­', lat: 36.38, lon: 126.47, region: 'ì¶©ë‚¨', station: 'DT_0025', stationName: 'ë³´ë ¹', current: '16LTC03', currentName: 'ì²œìˆ˜ë§Œ' },
        { name: 'ì‚¼ê¸¸í¬í•­', lat: 36.33, lon: 126.42, region: 'ì¶©ë‚¨', station: 'DT_0025', stationName: 'ë³´ë ¹', current: '16LTC03', currentName: 'ì²œìˆ˜ë§Œ' },
        { name: 'ëŒ€ì²œí•­', lat: 36.32, lon: 126.51, region: 'ì¶©ë‚¨', station: 'DT_0025', stationName: 'ë³´ë ¹', current: '07KS01', currentName: 'ì›ì‚°ë„' },
        { name: 'í™ì›í•­', lat: 36.30, lon: 126.48, region: 'ì¶©ë‚¨', station: 'DT_0025', stationName: 'ë³´ë ¹', current: '07KS01', currentName: 'ì›ì‚°ë„' },
        { name: 'ë¬´ì°½í¬', lat: 36.27, lon: 126.54, region: 'ì¶©ë‚¨', station: 'DT_0025', stationName: 'ë³´ë ¹', current: '07KS01', currentName: 'ì›ì‚°ë„' },
        { name: 'ì•ˆí¥ì™¸í•­', lat: 36.67, lon: 126.13, region: 'ì¶©ë‚¨', station: 'DT_0067', stationName: 'ì•ˆí¥', current: '07TA05', currentName: 'ì•ˆí¥' },
        { name: 'ê°„ì›”ë„', lat: 36.62, lon: 126.37, region: 'ì¶©ë‚¨', station: 'DT_0017', stationName: 'ëŒ€ì‚°', current: '17LTC06', currentName: 'ê°€ë¡œë¦¼ë§Œì…êµ¬' },
        { name: 'ê¶ë¦¬í¬êµ¬', lat: 36.78, lon: 126.12, region: 'ì¶©ë‚¨', station: 'DT_0050', stationName: 'íƒœì•ˆ', current: '07TA03', currentName: 'íƒœì•ˆ' },
        { name: 'ê²©í¬í•­', lat: 35.62, lon: 126.47, region: 'ì „ë¶', station: 'DT_0068', stationName: 'ìœ„ë„', current: '15LTC03', currentName: 'ìœ„ë„ë™ì¸¡' },
        { name: 'ë¶€ì•ˆë³€ì‚°', lat: 35.67, lon: 126.51, region: 'ì „ë¶', station: 'DT_0068', stationName: 'ìœ„ë„', current: '15LTC03', currentName: 'ìœ„ë„ë™ì¸¡' },
        { name: 'ë¹„ì‘í•­', lat: 35.97, lon: 126.62, region: 'ì „ë¶', station: 'DT_0018', stationName: 'êµ°ì‚°', current: '12JB14', currentName: 'êµ°ì‚°í•­ì…êµ¬' },
        { name: 'ì„ ìœ ë„', lat: 35.82, lon: 126.42, region: 'ì „ë¶', station: 'DT_0018', stationName: 'êµ°ì‚°', current: '06GS07', currentName: 'ê³ êµ°ì‚°êµ°ë„' },
        { name: 'ë…¹ë™í•­', lat: 34.48, lon: 127.08, region: 'ì „ë‚¨', station: 'DT_0026', stationName: 'ê³ í¥ë°œí¬', current: '06YS09', currentName: 'ê±°ê¸ˆìˆ˜ë„' },
        { name: 'ë§ˆëŸ‰í•­', lat: 34.38, lon: 126.38, region: 'ì „ë‚¨', station: 'DT_0007', stationName: 'ëª©í¬', current: '22LTC12', currentName: 'ë§ˆëŸ‰í•­' },
        { name: 'í•˜íš¨í•­', lat: 33.23, lon: 126.58, region: 'ì œì£¼', station: 'DT_0010', stationName: 'ì„œê·€í¬', current: '08JJ07', currentName: 'ì„œê·€í¬' },
        { name: 'ê¹€ë…•í•­', lat: 33.55, lon: 126.77, region: 'ì œì£¼', station: 'DT_0022', stationName: 'ì„±ì‚°í¬', current: '08JJ03', currentName: 'ì„±ì‚°í¬' },
        { name: 'í•œë¦¼í•­', lat: 33.42, lon: 126.27, region: 'ì œì£¼', station: 'DT_0004', stationName: 'ì œì£¼', current: '08JJ13', currentName: 'ì• ì›”í•­ë¶ì¸¡' },
        { name: 'ëŒ€í¬í•­', lat: 35.16, lon: 129.18, region: 'ê²½ë‚¨', station: 'DT_0005', stationName: 'ë¶€ì‚°', current: '18LTC13', currentName: 'í•´ìš´ëŒ€' },
        { name: 'êµ¬ë£¡í¬í•­', lat: 35.98, lon: 129.57, region: 'ê²½ë¶', station: 'DT_0091', stationName: 'í¬í•­', current: '17LTC05', currentName: 'ìš¸ë„' },
        { name: 'ì¶•ì‚°í•­', lat: 36.43, lon: 129.45, region: 'ê²½ë¶', station: 'DT_0011', stationName: 'í›„í¬', current: '17LTC07', currentName: 'ìš¸ë„ë‚¨ì¸¡' },
        { name: 'ì¥í˜¸í•­', lat: 37.28, lon: 129.33, region: 'ê°•ì›', station: 'DT_0057', stationName: 'ë™í•´í•­', current: null, currentName: null },
        { name: 'ì„ì›í•­', lat: 37.25, lon: 129.35, region: 'ê°•ì›', station: 'DT_0057', stationName: 'ë™í•´í•­', current: null, currentName: null },
    ];
    window._selectedPort = null;

    // ==================== ê´€ì¸¡ì†Œ/ì¡°ë¥˜ ì—°ë™ ====================
    function getRegionByStationCode(code) {
        for (const r of REGIONS) {
            if (r.stations.some(s => s[0] === code)) return r;
        }
        return REGIONS[0];
    }

    function getRegionByCurrentCode(code) {
        for (const r of REGIONS) {
            if (r.currents.some(c => c[0] === code)) return r;
        }
        return null;
    }

    function buildStationSelect() {
        const sel = document.getElementById('stationSelect');
        sel.innerHTML = '';
        for (const r of REGIONS) {
            const og = document.createElement('optgroup');
            og.label = r.label;
            for (const [code, name] of r.stations) {
                const opt = document.createElement('option');
                opt.value = code; opt.textContent = name;
                og.appendChild(opt);
            }
            sel.appendChild(og);
        }
    }

    function buildCurrentSelect(region) {
        const sel = document.getElementById('currentSelect');
        sel.innerHTML = '';
        if (!region || region.currents.length === 0) {
            const opt = document.createElement('option');
            opt.value = ''; opt.textContent = '(ì´ ì§€ì—­ì— ì¡°ë¥˜ ì˜ˆë³´ì  ì—†ìŒ)';
            sel.appendChild(opt);
            return;
        }
        const og = document.createElement('optgroup');
        og.label = region.label;
        for (const [code, name] of region.currents) {
            const opt = document.createElement('option');
            opt.value = code; opt.textContent = name;
            og.appendChild(opt);
        }
        sel.appendChild(og);
    }

    function updateRegionBadges(region) {
        document.getElementById('stationRegion').textContent = region.label;
        document.getElementById('currentRegion').textContent = region.label;
    }

    function onStationChange() {
        const code = document.getElementById('stationSelect').value;
        const region = getRegionByStationCode(code);
        buildCurrentSelect(region);
        updateRegionBadges(region);
        requestFlowStatsPrime(code, getDateStr(), false);
        const currentCode = getCurrentStation();
        requestCurrentFlowStatsPrime(currentCode, getDateStr(), false);
    }

    // ==================== ê²€ìƒ‰ ê¸°ëŠ¥ ====================
    function buildSearchIndex() {
        const index = [];
        for (const r of REGIONS) {
            for (const [code, name] of r.stations) {
                index.push({ type: 'obs', code, name, region: r, regionLabel: r.label });
            }
            for (const [code, name] of r.currents) {
                index.push({ type: 'crnt', code, name, region: r, regionLabel: r.label });
            }
        }
        // ë‚šì‹œ í¬ì¸íŠ¸ í”„ë¦¬ì…‹ ì¶”ê°€
        for (const port of FISHING_PORTS) {
            index.push({ type: 'port', name: port.name, lat: port.lat, lon: port.lon, regionLabel: port.region });
        }
        return index;
    }

    const searchIndex = buildSearchIndex();

    function focusAndClearSearchInput(evt) {
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        if (!searchInput) return;

        const clickedSearchResult = !!(evt && evt.target && evt.target.closest && evt.target.closest('.search-results'));
        const isPrefilled = searchInput.dataset.prefilled === '1';
        if (!clickedSearchResult && isPrefilled) {
            searchInput.value = '';
            searchInput.dataset.prefilled = '0';
            if (searchResults) searchResults.classList.remove('show');
        }
        searchInput.focus();
    }

    // HTML escape ìœ í‹¸ â€” XSS ë°©ì§€
    function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    function doSearch(query) {
        const q = query.trim().toLowerCase().substring(0, 100);
        if (!q) return [];
        return searchIndex.filter(item =>
            item.name.toLowerCase().includes(q) ||
            item.regionLabel.toLowerCase().includes(q) ||
            (item.code && item.code.toLowerCase().includes(q))
        ).slice(0, 15);
    }

    function highlightMatch(text, query) {
        const safe = escapeHTML(text);
        const safeQ = escapeHTML(query);
        const idx = safe.toLowerCase().indexOf(safeQ.toLowerCase());
        if (idx < 0) return safe;
        return safe.substring(0, idx) + '<em>' + safe.substring(idx, idx + safeQ.length) + '</em>' + safe.substring(idx + safeQ.length);
    }

    function renderSearchResults(results, query) {
        const el = document.getElementById('searchResults');
        if (results.length === 0) {
            el.innerHTML = '<div class="search-no-result">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
            el.classList.add('show');
            return;
        }
        el.innerHTML = results.map((item, i) => {
            const typeLabel = item.type === 'obs' ? 'ê´€ì¸¡ì†Œ' : item.type === 'crnt' ? 'ì¡°ë¥˜ì˜ˆë³´ì ' : 'ğŸ“ ë‚šì‹œí¬ì¸íŠ¸';
            const typeClass = item.type === 'port' ? 'crnt' : item.type;
            return `
            <div class="search-result-item" data-idx="${i}">
                <div class="name">${highlightMatch(item.name, query)}</div>
                <div class="tags">
                    <span class="tag ${typeClass}">${typeLabel}</span>
                    <span class="tag region">${item.regionLabel}</span>
                </div>
            </div>`;
        }).join('');
        el.classList.add('show');

        el.querySelectorAll('.search-result-item').forEach(div => {
            div.addEventListener('click', () => {
                const idx = parseInt(div.dataset.idx);
                selectSearchResult(results[idx]);
            });
        });
    }

    function selectSearchResult(item) {
        const stationSel = document.getElementById('stationSelect');
        const currentSel = document.getElementById('currentSelect');

        if (item.type === 'port') {
            // ë‚šì‹œ í¬ì¸íŠ¸ â†’ ê¸°ì¡´ ê´€ì¸¡ì†Œ/ì¡°ë¥˜ ì»¨íŠ¸ë¡¤ì— ì—°ê²°
            const port = FISHING_PORTS.find(p => p.name === item.name);
            if (!port) return;

            // ê´€ì¸¡ì†Œ ì„¤ì •
            stationSel.value = port.station;
            const region = getRegionByStationCode(port.station);
            buildCurrentSelect(region);
            updateRegionBadges(region);

            // ì¡°ë¥˜ ì˜ˆë³´ì  ì„¤ì •
            if (port.current) {
                currentSel.value = port.current;
            }
            window._selectedPort = port;

            // í¬íŠ¸ ì •ë³´ ì„¤ì • (ë°°ë„ˆ ìˆ¨ê¸°ê³  ê²€ìƒ‰ë°”ì— í‘œì‹œ)
            document.getElementById('portBannerName').textContent = port.name;
            document.getElementById('portBannerStation').textContent = `${port.stationName} (${port.station})`;
            document.getElementById('portBannerCurrent').textContent = port.current ? `${port.currentName} (${port.current})` : 'ì˜ˆë³´ì  ì—†ìŒ';
            document.getElementById('portBanner').style.display = 'none';
            // ê²€ìƒ‰ë°” ë‚´ë¶€ ì •ë³´ í‘œì‹œ
            document.getElementById('searchPortStation').textContent = `${port.stationName} (${port.station})`;
            document.getElementById('searchPortCurrent').textContent = port.current ? `${port.currentName} (${port.current})` : 'ì˜ˆë³´ì  ì—†ìŒ';
            document.getElementById('searchPortInfo').style.display = '';

            // ë¬¼ë•Œ/ì¡°ìœ„ íƒ­ìœ¼ë¡œ ì „í™˜
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab="tide"]').classList.add('active');
            document.getElementById('tab-tide').classList.add('active');

            // ê²€ìƒ‰ì°½ ë‹«ê¸°
            document.getElementById('searchInput').value = item.name;
            document.getElementById('searchInput').dataset.prefilled = '1';
            document.getElementById('searchResults').classList.remove('show');

            // ìë™ ì¡°íšŒ
            fetchAll();
            return;
        }

        // í•´ë‹¹ ì§€ì—­ì˜ ê´€ì¸¡ì†Œë¥¼ ì²« ë²ˆì§¸ë¡œ ì„ íƒ
        const region = item.region;
        if (item.type === 'obs') {
            stationSel.value = item.code;
        } else {
            // ì¡°ë¥˜ì˜ˆë³´ì ì´ë©´ í•´ë‹¹ ì§€ì—­ì˜ ì²« ë²ˆì§¸ ê´€ì¸¡ì†Œ ì„ íƒ
            if (region.stations.length > 0) {
                stationSel.value = region.stations[0][0];
            }
        }
        // ì§€ì—­ì— ë§ëŠ” ì¡°ë¥˜ ì˜ˆë³´ì  ëª©ë¡ ê°±ì‹ 
        buildCurrentSelect(region);
        updateRegionBadges(region);

        if (item.type === 'crnt') {
            currentSel.value = item.code;
        }
        window._selectedPort = null;

        // ë°°ë„ˆ ìˆ¨ê¸°ê¸°
        document.getElementById('portBanner').style.display = 'none';
        document.getElementById('searchPortInfo').style.display = 'none';

        // ê²€ìƒ‰ì°½ ë‹«ê¸°
        document.getElementById('searchInput').value = item.name;
        document.getElementById('searchInput').dataset.prefilled = '1';
        document.getElementById('searchResults').classList.remove('show');

        // ìë™ ì¡°íšŒ
        fetchAll();
    }

    // ==================== INIT ====================
    document.addEventListener('DOMContentLoaded', () => {
        const today = new Date();
        document.getElementById('dateInput').value = today.toISOString().split('T')[0];
        updateDateDisplay();
        document.getElementById('dateInput').addEventListener('change', () => { updateDateDisplay(); fetchAll(); });

        // ê´€ì¸¡ì†Œ/ì¡°ë¥˜ ì—°ë™ ì´ˆê¸°í™”
        buildStationSelect();
        onStationChange();
        document.getElementById('stationSelect').addEventListener('change', onStationChange);

        // ê¸°ë³¸ê°’: ì˜¤ì²œí•­
        let initialFetchTriggered = false;
        const defaultPort = FISHING_PORTS.find(p => p.name === 'ì˜¤ì²œí•­');
        if (defaultPort) {
            selectSearchResult({ name: defaultPort.name, type: 'port' });
            initialFetchTriggered = true;
        }

        // í¬ì¸íŠ¸ ë°°ë„ˆ ë‹«ê¸° ë²„íŠ¼
        document.getElementById('portBannerClose').addEventListener('click', () => {
            document.getElementById('portBanner').style.display = 'none';
            document.getElementById('searchPortInfo').style.display = 'none';
        });

        // íƒ­ ì „í™˜
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
            });
        });

        // ê²€ìƒ‰ ì´ë²¤íŠ¸
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        let debounceTimer = null;

        searchInput.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            searchInput.dataset.prefilled = '0';
            debounceTimer = setTimeout(() => {
                const q = searchInput.value.trim();
                if (q.length === 0) { searchResults.classList.remove('show'); return; }
                const results = doSearch(q);
                renderSearchResults(results, q);
            }, 150);
        });

        searchInput.addEventListener('focus', () => {
            const q = searchInput.value.trim();
            if (q.length > 0) {
                const results = doSearch(q);
                renderSearchResults(results, q);
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-bar')) {
                searchResults.classList.remove('show');
            }
        });

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') searchResults.classList.remove('show');
            if (e.key === 'Enter') {
                e.preventDefault();
                const q = searchInput.value.trim();
                if (q.length === 0) return;
                const results = doSearch(q);
                if (results.length > 0) {
                    selectSearchResult(results[0]);
                    searchInput.blur();
                }
            }
        });

        // ì ‘ì† ì‹œ ì˜¤ëŠ˜ ë‚ ì§œ ë°ì´í„° ìë™ ì¡°íšŒ ë³´ì¥
        if (!initialFetchTriggered) {
            fetchAll();
        }
    });

    function showToast(msg, isError = false) {
        let toast = document.getElementById('toastMsg');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'toastMsg';
            toast.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:12px 24px;border-radius:8px;color:#fff;font-size:14px;z-index:9999;opacity:0;transition:opacity 0.3s;pointer-events:none;';
            document.body.appendChild(toast);
        }
        toast.textContent = msg;
        toast.style.background = isError ? '#e74c3c' : '#00e0ff';
        toast.style.color = isError ? '#fff' : '#0a0f1a';
        toast.style.opacity = '1';
        setTimeout(() => { toast.style.opacity = '0'; }, 2500);
    }

    function updateDateDisplay() {
        const v = document.getElementById('dateInput').value;
        if (!v) return;
        const [y, m, d] = v.split('-');
        document.getElementById('dateDisplay').textContent = y + 'ë…„ ' + m + 'ì›” ' + d + 'ì¼';
    }
    function shiftMonth(dir) {
        const inp = document.getElementById('dateInput');
        const d = new Date(inp.value);
        d.setMonth(d.getMonth() + dir);
        inp.value = d.toISOString().split('T')[0];
        updateDateDisplay();
        fetchAll();
    }
    function shiftDay(dir) {
        const inp = document.getElementById('dateInput');
        const d = new Date(inp.value);
        d.setDate(d.getDate() + dir);
        inp.value = d.toISOString().split('T')[0];
        updateDateDisplay();
        fetchAll();
    }
    function getDateStr() {
        const v = document.getElementById('dateInput').value;
        if (!/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date().toISOString().split('T')[0].replace(/-/g, '');
        return v.replace(/-/g, '');
    }
    function getStation() { return document.getElementById('stationSelect').value; }
    function getCurrentStation() { return document.getElementById('currentSelect').value; }

    // ==================== ìŒë ¥ ë³€í™˜ & ë¬¼ë•Œ ê³„ì‚° ====================
    // korean-lunar-calendar ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© (KASI ê¸°ë°˜ ì •í™•í•œ ìŒë ¥ ë³€í™˜)
    function solarToLunar(year, month, day) {
        try {
            const cal = new KoreanLunarCalendar();
            cal.setSolarDate(year, month, day);
            const lunar = cal.getLunarCalendar();
            return {
                lunarMonth: lunar.month,
                lunarDay: lunar.day,
                isLeapMonth: lunar.intercalation
            };
        } catch (e) {
            console.error('ìŒë ¥ ë³€í™˜ ì˜¤ë¥˜:', e);
            return { lunarMonth: 1, lunarDay: 1, isLeapMonth: false };
        }
    }

    // moon/moon í´ë” íŒŒì¼ ìˆœì„œ ê¸°ë°˜ ì›”ë ¹ ì•„ì´ì½˜ ë§¤í•‘
    const MOON_PHASE_IMAGE_DAYS = [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 23, 24, 25, 26];
    function getMoonPhaseIconSrc(lunarDay) {
        const safeDay = (typeof lunarDay === 'number' && lunarDay >= 1 && lunarDay <= 30) ? lunarDay : 1;
        let nearestDay = MOON_PHASE_IMAGE_DAYS[0];
        let minDiff = Math.abs(safeDay - nearestDay);
        for (const day of MOON_PHASE_IMAGE_DAYS) {
            const diff = Math.abs(safeDay - day);
            if (diff < minDiff || (diff === minDiff && day > nearestDay)) {
                minDiff = diff;
                nearestDay = day;
            }
        }
        return `moon/moon/moon_${String(nearestDay).padStart(2, '0')}.png`;
    }

    function getMulddae(lunarDay) {
        // ë°”ë‹¤íƒ€ì„ ê¸°ì¤€ 7ë¬¼ë•Œì‹ (ì„œí•´ í‘œì¤€)
        // pctëŠ” ê¸°ë³¸ ì¶”ì •ê°’ (ì‹¤ì œ ì¡°ì°¨ ë°ì´í„°ë¡œ ë®ì–´ì“¸ ìˆ˜ ìˆìŒ)
        const mulddaeMap = {
            1:  { name: 'ì‚¬ë¦¬', num: '7ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 98 },
            2:  { name: 'ì‚¬ë¦¬', num: '8ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 95 },
            3:  { name: 'ì‚¬ë¦¬', num: '9ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 90 },
            4:  { name: 'ì‚¬ë¦¬', num: '10ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 83 },
            5:  { name: 'ì‚¬ë¦¬', num: '11ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 73 },
            6:  { name: 'ì‚¬ë¦¬', num: '12ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 60 },
            7:  { name: 'ì‚¬ë¦¬', num: '13ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 45 },
            8:  { name: 'ì¡°ê¸ˆ', num: 'ì¡°ê¸ˆ', color: '#4ecdc4', emoji: 'ğŸŸ¢', pct: 30 },
            9:  { name: 'ë¬´ì‹œ', num: 'ë¬´ì‹œ', color: '#7a8ba3', emoji: 'âšª', pct: 25 },
            10: { name: 'ë“¤ë¬¼', num: '1ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 33 },
            11: { name: 'ë“¤ë¬¼', num: '2ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 43 },
            12: { name: 'ë“¤ë¬¼', num: '3ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 55 },
            13: { name: 'ë“¤ë¬¼', num: '4ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 68 },
            14: { name: 'ë“¤ë¬¼', num: '5ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 80 },
            15: { name: 'ì‚¬ë¦¬', num: '6ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 90 },
            16: { name: 'ì‚¬ë¦¬', num: '7ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 98 },
            17: { name: 'ì‚¬ë¦¬', num: '8ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 95 },
            18: { name: 'ì‚¬ë¦¬', num: '9ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 90 },
            19: { name: 'ì‚¬ë¦¬', num: '10ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 83 },
            20: { name: 'ì‚¬ë¦¬', num: '11ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 73 },
            21: { name: 'ì‚¬ë¦¬', num: '12ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 60 },
            22: { name: 'ì‚¬ë¦¬', num: '13ë¬¼', color: '#ffa726', emoji: 'ğŸŸ ', pct: 45 },
            23: { name: 'ì¡°ê¸ˆ', num: 'ì¡°ê¸ˆ', color: '#4ecdc4', emoji: 'ğŸŸ¢', pct: 30 },
            24: { name: 'ë¬´ì‹œ', num: 'ë¬´ì‹œ', color: '#7a8ba3', emoji: 'âšª', pct: 25 },
            25: { name: 'ë“¤ë¬¼', num: '1ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 33 },
            26: { name: 'ë“¤ë¬¼', num: '2ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 43 },
            27: { name: 'ë“¤ë¬¼', num: '3ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 55 },
            28: { name: 'ë“¤ë¬¼', num: '4ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 68 },
            29: { name: 'ë“¤ë¬¼', num: '5ë¬¼', color: '#4fc3f7', emoji: 'ğŸ”µ', pct: 80 },
            30: { name: 'ì‚¬ë¦¬', num: '6ë¬¼', color: '#ff6b6b', emoji: 'ğŸ”´', pct: 90 },
        };
        const safeDay = (lunarDay >= 1 && lunarDay <= 30) ? lunarDay : 1;
        return mulddaeMap[safeDay] || mulddaeMap[1];
    }

    // ê´€ì¸¡ì†Œë³„ ì‚¬ë¦¬ ê¸°ì¤€ ìµœëŒ€ ì¡°ì°¨ (cm) - ì‹¤ì¸¡ ê¸°ë°˜ ì°¸ê³ ê°’
    const MAX_TIDAL_RANGE = {
        // ì¸ì²œ/ê²½ê¸°
        'DT_0001': 900, 'DT_0052': 880, 'DT_0044': 870, 'DT_0032': 850,
        'DT_0043': 850, 'DT_0093': 860, 'DT_0065': 800, 'DT_0066': 780,
        'DT_0002': 850, 'DT_0008': 870,
        // ì¶©ë‚¨/ì „ë¶
        'DT_0050': 700, 'DT_0067': 650, 'DT_0017': 750, 'DT_0025': 750,
        'DT_0051': 650, 'DT_0024': 650, 'DT_0018': 600, 'DT_0068': 450, 'DT_0037': 400,
        // ì „ë‚¨ì„œë¶€
        'DT_0007': 400, 'DT_0035': 300, 'DT_0094': 350,
        // ì „ë‚¨ë™ë¶€
        'DT_0028': 350, 'DT_0027': 350, 'DT_0026': 350, 'DT_0092': 320,
        'DT_0016': 300, 'DT_0049': 300, 'DT_0031': 250,
        // ë‚¨í•´/ê²½ë‚¨
        'DT_0061': 250, 'DT_0014': 200, 'DT_0003': 200, 'DT_0029': 200,
        'DT_0063': 180, 'DT_0062': 180, 'DT_0056': 150,
        'DT_0013': 150, 'DT_0033': 180, 'DT_0015': 150, 'DT_0048': 130, 'DT_0030': 120,
        // ë¶€ì‚°/ìš¸ì‚°
        'DT_0005': 120, 'DT_0020': 50,
        // ë™í•´
        'DT_0091': 30, 'DT_0039': 30, 'DT_0011': 30, 'DT_0057': 30,
        'DT_0006': 35, 'DT_0012': 30,
        'DT_0019': 30, 'DT_0034': 30, 'DT_0036': 25,
        // ì œì£¼
        'DT_0004': 250, 'DT_0022': 200, 'DT_0010': 200, 'DT_0023': 200, 'DT_0021': 350,
        // íŠ¹ìˆ˜ (êµë³¸ì´ˆ/ì´ì–´ë„/ê°€ê±°ì´ˆ/ì†Œì²­ì´ˆ)
        'DT_0042': 300, 'IE_0060': 200, 'IE_0061': 350, 'IE_0062': 800,
    };

    // ==================== ë¬¼íë¦„ ë™ì  ì •ê·œí™” (ê´€ì¸¡ì†Œë³„ p10/p90) ====================
    const FLOW_STATS_CACHE_PREFIX = 'flowStats.v2.';
    const FLOW_STATS_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7; // 7ì¼
    const FLOW_STATS_LOOKBACK_DAYS = 180;
    const FLOW_STATS_STEP_DAYS = 5; // tide-hilo ì‘ë‹µì´ ë©°ì¹ ì¹˜ ë¬¶ìŒì´ë¼ 5ì¼ ê°„ê²© ìˆ˜ì§‘
    const FLOW_STATS_MIN_SAMPLES = 24;
    const FLOW_STATS_FETCH_CONCURRENCY = 4;
    const flowStatsMemoryCache = {};
    const flowStatsInFlight = {};

    function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
    }

    function formatDateKey(dateObj) {
        const y = dateObj.getFullYear();
        const m = String(dateObj.getMonth() + 1).padStart(2, '0');
        const d = String(dateObj.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
    }

    function formatReqDate(dateObj) {
        const y = dateObj.getFullYear();
        const m = String(dateObj.getMonth() + 1).padStart(2, '0');
        const d = String(dateObj.getDate()).padStart(2, '0');
        return `${y}${m}${d}`;
    }

    function parseReqDate(reqDate) {
        if (!/^\d{8}$/.test(reqDate || '')) return null;
        const y = parseInt(reqDate.substring(0, 4), 10);
        const m = parseInt(reqDate.substring(4, 6), 10);
        const d = parseInt(reqDate.substring(6, 8), 10);
        const dt = new Date(y, m - 1, d);
        return Number.isNaN(dt.getTime()) ? null : dt;
    }

    function addDays(dateObj, days) {
        const d = new Date(dateObj);
        d.setDate(d.getDate() + days);
        return d;
    }

    function startOfDay(dateObj) {
        const d = new Date(dateObj);
        d.setHours(0, 0, 0, 0);
        return d;
    }

    function getDaysAheadFromToday(dateStr) {
        const target = parseReqDate(dateStr);
        if (!target) return null;
        const today = startOfDay(new Date());
        const targetDay = startOfDay(target);
        return Math.round((targetDay.getTime() - today.getTime()) / 86400000);
    }

    const FLOW_WEIGHT_PROFILE_DEFAULT = { midStart: 0.35, midEnd: 0.70, near: 0.85 };
    const FLOW_WEIGHT_PROFILE_BY_STATION = {
        // ì˜¤ì²œê¶Œ(ë³´ë ¹) ë°±í…ŒìŠ¤íŠ¸(2026, badatime 355) ê¸°ë°˜ ë³´ì •
        // ê²¨ìš¸: ìœ ì† ë°˜ì˜ ë‚®ê²Œ, ì—¬ë¦„: ìœ ì† ë°˜ì˜ ë†’ê²Œ
        'DT_0025': {
            cold: { midStart: 0.15, midEnd: 0.30, near: 0.35 },     // 11~4ì›”
            shoulder: { midStart: 0.30, midEnd: 0.50, near: 0.55 }, // 5,10ì›”
            warm: { midStart: 0.45, midEnd: 0.72, near: 0.80 },     // 6~9ì›”
        },
    };

    function getFlowSeason(dateStr) {
        if (!/^\d{8}$/.test(dateStr || '')) return 'shoulder';
        const month = parseInt(dateStr.substring(4, 6), 10);
        if ([11, 12, 1, 2, 3, 4].includes(month)) return 'cold';
        if ([6, 7, 8, 9].includes(month)) return 'warm';
        return 'shoulder';
    }

    function getFlowWeightProfile(dateStr, stationCode) {
        const season = getFlowSeason(dateStr);
        const byStation = stationCode ? FLOW_WEIGHT_PROFILE_BY_STATION[stationCode] : null;
        const profile = (byStation && byStation[season]) ? byStation[season] : FLOW_WEIGHT_PROFILE_DEFAULT;
        const midStart = clamp(Number(profile.midStart), 0, 1);
        const midEnd = clamp(Number(profile.midEnd), 0, 1);
        const near = clamp(Number(profile.near), 0, 1);
        return { season, midStart, midEnd, near, tuned: !!byStation };
    }

    function getFlowRecencyPolicy(dateStr, stationCode) {
        const daysAhead = getDaysAheadFromToday(dateStr);
        if (!Number.isFinite(daysAhead)) return null;
        const weights = getFlowWeightProfile(dateStr, stationCode);

        if (daysAhead >= 8) {
            return { stage: 'far', daysAhead, currentWeight: 0, rangeWeight: 1, label: 'ì¥ê¸°ì˜ˆì¸¡', ...weights };
        }

        if (daysAhead >= 2) {
            const t = clamp((7 - daysAhead) / 5, 0, 1); // D-7 -> 0, D-2 -> 1
            const currentWeight = weights.midStart + (weights.midEnd - weights.midStart) * t;
            return {
                stage: 'mid',
                daysAhead,
                currentWeight,
                rangeWeight: 1 - currentWeight,
                label: 'ê·¼ì ‘ë³´ì •',
                ...weights
            };
        }

        // D-1, ë‹¹ì¼, ê³¼ê±°ì¼: ìµœì‹  ìœ ì†ê°’ ë¹„ì¤‘ì„ ë†’ì—¬ ë°˜ì˜
        const currentWeight = weights.near;
        return {
            stage: 'near',
            daysAhead,
            currentWeight,
            rangeWeight: 1 - currentWeight,
            label: daysAhead === 1 ? 'D-1 ë³´ì •' : (daysAhead === 0 ? 'ë‹¹ì¼ë³´ì •' : 'ì‚¬í›„ë³´ì •'),
            ...weights
        };
    }

    function formatFlowLeadText(daysAhead) {
        if (!Number.isFinite(daysAhead)) return '';
        if (daysAhead > 0) return `D-${daysAhead}`;
        if (daysAhead === 0) return 'ë‹¹ì¼';
        return `D+${Math.abs(daysAhead)}`;
    }

    function percentile(sortedValues, p) {
        if (!sortedValues || sortedValues.length === 0) return null;
        if (sortedValues.length === 1) return sortedValues[0];
        const idx = (sortedValues.length - 1) * clamp(p, 0, 1);
        const lo = Math.floor(idx);
        const hi = Math.ceil(idx);
        if (lo === hi) return sortedValues[lo];
        const w = idx - lo;
        return sortedValues[lo] * (1 - w) + sortedValues[hi] * w;
    }

    function getFlowStatsCacheKey(stationCode) {
        return FLOW_STATS_CACHE_PREFIX + stationCode;
    }

    function getCachedFlowStats(stationCode) {
        if (!stationCode) return null;
        try {
            const raw = localStorage.getItem(getFlowStatsCacheKey(stationCode));
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            if (!Number.isFinite(parsed.p10) || !Number.isFinite(parsed.p90)) return null;
            if (typeof parsed.updatedAt !== 'string') return null;
            return parsed;
        } catch {
            return null;
        }
    }

    function setCachedFlowStats(stationCode, stats) {
        if (!stationCode || !stats) return;
        try {
            localStorage.setItem(getFlowStatsCacheKey(stationCode), JSON.stringify(stats));
        } catch {
            // localStorage ì‚¬ìš© ë¶ˆê°€ í™˜ê²½ì€ ë©”ëª¨ë¦¬ ìºì‹œë§Œ ì‚¬ìš©
        }
    }

    function getFlowStats(stationCode) {
        if (!stationCode) return null;
        if (flowStatsMemoryCache[stationCode]) return flowStatsMemoryCache[stationCode];
        const cached = getCachedFlowStats(stationCode);
        if (cached) {
            flowStatsMemoryCache[stationCode] = cached;
            return cached;
        }
        return null;
    }

    function isFlowStatsUsable(stats, dateStr) {
        if (!stats) return false;
        if (!Number.isFinite(stats.p10) || !Number.isFinite(stats.p90) || stats.p90 <= stats.p10) return false;
        if (!stats.updatedAt) return false;
        const updatedAt = Date.parse(stats.updatedAt);
        if (!Number.isFinite(updatedAt)) return false;
        if ((Date.now() - updatedAt) > FLOW_STATS_CACHE_TTL_MS) return false;
        if (!dateStr || !/^\d{8}$/.test(dateStr)) return true;
        if (!stats.windowStart || !stats.windowEnd) return true;
        const dateKey = `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
        return dateKey >= stats.windowStart && dateKey <= stats.windowEnd;
    }

    function collectDailyDiffsFromItems(items) {
        const byDay = {};
        for (const item of items || []) {
            const predcDt = String(item.predcDt || '');
            if (predcDt.length < 16) continue;
            const dateKey = predcDt.substring(0, 10);
            const time = predcDt.substring(11, 16);
            if (time < '05:00' || time > '18:00') continue;

            const level = parseFloat(item.predcTdlvVl);
            const extrSe = parseInt(item.extrSe, 10);
            if (!Number.isFinite(level) || !Number.isFinite(extrSe)) continue;

            if (!byDay[dateKey]) byDay[dateKey] = { highs: [], lows: [] };
            if (extrSe % 2 === 1) byDay[dateKey].highs.push(level);
            else byDay[dateKey].lows.push(level);
        }

        const diffs = {};
        Object.entries(byDay).forEach(([dateKey, v]) => {
            if (v.highs.length === 0 || v.lows.length === 0) return;
            const diff = Math.max(...v.highs) - Math.min(...v.lows);
            if (Number.isFinite(diff) && diff > 0) diffs[dateKey] = diff;
        });
        return diffs;
    }

    async function buildFlowStatsForStation(stationCode, baseDateStr) {
        const endDate = parseReqDate(baseDateStr);
        if (!endDate) return null;
        const startDate = addDays(endDate, -FLOW_STATS_LOOKBACK_DAYS);
        const startKey = formatDateKey(startDate);
        const endKey = formatDateKey(endDate);

        const reqDates = [];
        for (let d = new Date(startDate); d <= endDate; d = addDays(d, FLOW_STATS_STEP_DAYS)) {
            reqDates.push(formatReqDate(d));
        }
        if (reqDates[reqDates.length - 1] !== baseDateStr) {
            reqDates.push(baseDateStr);
        }

        const dayDiffMap = {};
        for (let i = 0; i < reqDates.length; i += FLOW_STATS_FETCH_CONCURRENCY) {
            const chunk = reqDates.slice(i, i + FLOW_STATS_FETCH_CONCURRENCY);
            const responses = await Promise.all(chunk.map(async (reqDate) => {
                try {
                    const items = await apiCall('tideFcstHghLw/GetTideFcstHghLwApiService', {
                        obsCode: stationCode,
                        reqDate,
                        numOfRows: '20',
                        pageNo: '1'
                    });
                    return items;
                } catch {
                    return [];
                }
            }));

            for (const items of responses) {
                const dailyDiffs = collectDailyDiffsFromItems(items);
                Object.entries(dailyDiffs).forEach(([dateKey, diff]) => {
                    if (dateKey < startKey || dateKey > endKey) return;
                    dayDiffMap[dateKey] = diff;
                });
            }
        }

        const diffs = Object.values(dayDiffMap).filter(v => Number.isFinite(v) && v > 0).sort((a, b) => a - b);
        if (diffs.length < FLOW_STATS_MIN_SAMPLES) return null;

        const p10 = percentile(diffs, 0.10);
        const p90 = percentile(diffs, 0.90);
        if (!Number.isFinite(p10) || !Number.isFinite(p90) || p90 <= p10) return null;

        return {
            stationCode,
            p10: Math.round(p10 * 10) / 10,
            p90: Math.round(p90 * 10) / 10,
            sampleCount: diffs.length,
            windowStart: startKey,
            windowEnd: endKey,
            updatedAt: new Date().toISOString(),
        };
    }

    async function primeFlowStats(stationCode, dateStr) {
        if (!stationCode || !/^\d{8}$/.test(dateStr || '')) return false;
        const existing = getFlowStats(stationCode);
        if (isFlowStatsUsable(existing, dateStr)) return false;
        if (flowStatsInFlight[stationCode]) return flowStatsInFlight[stationCode];

        flowStatsInFlight[stationCode] = (async () => {
            const stats = await buildFlowStatsForStation(stationCode, dateStr);
            if (!stats) return false;
            flowStatsMemoryCache[stationCode] = stats;
            setCachedFlowStats(stationCode, stats);
            return true;
        })().catch(() => false).finally(() => {
            delete flowStatsInFlight[stationCode];
        });

        return flowStatsInFlight[stationCode];
    }

    function requestFlowStatsPrime(stationCode, dateStr, refreshOnUpdate = false) {
        primeFlowStats(stationCode, dateStr).then((updated) => {
            if (!updated || !refreshOnUpdate) return;
            if (stationCode !== getStation() || dateStr !== getDateStr()) return;
            fetchTideHighLow();
        }).catch(() => {});
    }

    // ì¡°ì°¨ ê¸°ë°˜ ë³´ì¡° ì§€í‘œ ê³„ì‚° (fallback)
    function calcRangeFlowPct(diff, stationCode, dateStr) {
        if (diff == null || diff <= 0) return null;

        // ë™ì  ì •ê·œí™”ê°€ ì¤€ë¹„ë˜ì–´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš© (0~100 ê³ ì •)
        const stats = getFlowStats(stationCode);
        if (isFlowStatsUsable(stats, dateStr)) {
            const normalized = ((diff - stats.p10) / (stats.p90 - stats.p10)) * 100;
            return Math.round(clamp(normalized, 0, 100));
        }

        // fallback: ê´€ì¸¡ì†Œë³„ ìµœëŒ€ ì¡°ì°¨ ê¸°ì¤€ (ê¸°ì¡´ ë°©ì‹, ìµœì†Œ 5% í•˜í•œ ì œê±°)
        const maxRange = MAX_TIDAL_RANGE[stationCode] || 300; // fallback: ë¯¸ë“±ë¡ ê´€ì¸¡ì†Œìš© ì¤‘ê°„ê°’
        const pct = Math.round(Math.min(100, (diff / maxRange) * 100));
        return Math.max(0, pct);
    }

    function getMulddaeInfo(dateStr) {
        const y = parseInt(dateStr.substring(0, 4));
        const m = parseInt(dateStr.substring(4, 6));
        const d = parseInt(dateStr.substring(6, 8));
        const lunar = solarToLunar(y, m, d);
        const mulddae = getMulddae(lunar.lunarDay);
        return { ...mulddae, lunarMonth: lunar.lunarMonth, lunarDay: lunar.lunarDay };
    }

    // ==================== ë¬¼íë¦„(ìœ ì† crsp) ê¸°ë°˜ í¼ì„¼íŠ¸ ====================
    const CURRENT_FLOW_STATS_CACHE_PREFIX = 'currentFlowStats.v1.';
    const CURRENT_FLOW_STATS_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7; // 7ì¼
    const CURRENT_FLOW_LOOKBACK_DAYS = FLOW_STATS_LOOKBACK_DAYS;
    const CURRENT_FLOW_STEP_DAYS = FLOW_STATS_STEP_DAYS;
    const CURRENT_FLOW_MIN_SAMPLES = FLOW_STATS_MIN_SAMPLES;
    const CURRENT_FLOW_FETCH_CONCURRENCY = FLOW_STATS_FETCH_CONCURRENCY;
    const currentFlowStatsMemoryCache = {};
    const currentFlowStatsInFlight = {};
    const currentFlowSnapshotCache = {};
    let mulddaeCardState = null;
    window._lastMulddaePct = null;
    window._fishingIndexInfo = null;

    function getCurrentFlowStatsCacheKey(currentCode) {
        return CURRENT_FLOW_STATS_CACHE_PREFIX + currentCode;
    }

    function getCachedCurrentFlowStats(currentCode) {
        if (!currentCode) return null;
        try {
            const raw = localStorage.getItem(getCurrentFlowStatsCacheKey(currentCode));
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return null;
            if (!Number.isFinite(parsed.p10) || !Number.isFinite(parsed.p90)) return null;
            if (typeof parsed.updatedAt !== 'string') return null;
            return parsed;
        } catch {
            return null;
        }
    }

    function setCachedCurrentFlowStats(currentCode, stats) {
        if (!currentCode || !stats) return;
        try {
            localStorage.setItem(getCurrentFlowStatsCacheKey(currentCode), JSON.stringify(stats));
        } catch {
            // localStorage ì‚¬ìš© ë¶ˆê°€ í™˜ê²½ì€ ë©”ëª¨ë¦¬ ìºì‹œë§Œ ì‚¬ìš©
        }
    }

    function getCurrentFlowStats(currentCode) {
        if (!currentCode) return null;
        if (currentFlowStatsMemoryCache[currentCode]) return currentFlowStatsMemoryCache[currentCode];
        const cached = getCachedCurrentFlowStats(currentCode);
        if (cached) {
            currentFlowStatsMemoryCache[currentCode] = cached;
            return cached;
        }
        return null;
    }

    function isCurrentFlowStatsUsable(stats, dateStr) {
        if (!stats) return false;
        if (!Number.isFinite(stats.p10) || !Number.isFinite(stats.p90) || stats.p90 <= stats.p10) return false;
        if (!stats.updatedAt) return false;
        const updatedAt = Date.parse(stats.updatedAt);
        if (!Number.isFinite(updatedAt)) return false;
        if ((Date.now() - updatedAt) > CURRENT_FLOW_STATS_CACHE_TTL_MS) return false;
        if (!dateStr || !/^\d{8}$/.test(dateStr)) return true;
        if (!stats.windowStart || !stats.windowEnd) return true;
        const dateKey = `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
        return dateKey >= stats.windowStart && dateKey <= stats.windowEnd;
    }

    function collectDailyMaxSpeedsFromItems(items) {
        const byDay = {};
        for (const item of items || []) {
            const predcDt = String(item.predcDt || '');
            if (predcDt.length < 16) continue;
            const dateKey = predcDt.substring(0, 10);
            const time = predcDt.substring(11, 16);
            if (time < '05:00' || time > '18:00') continue;

            const speed = parseFloat(item.crsp);
            if (!Number.isFinite(speed) || speed < 0) continue;
            if (!Number.isFinite(byDay[dateKey]) || speed > byDay[dateKey]) {
                byDay[dateKey] = speed;
            }
        }
        return byDay;
    }

    async function buildCurrentFlowStatsForStation(currentCode, baseDateStr) {
        const endDate = parseReqDate(baseDateStr);
        if (!endDate) return null;
        const startDate = addDays(endDate, -CURRENT_FLOW_LOOKBACK_DAYS);
        const startKey = formatDateKey(startDate);
        const endKey = formatDateKey(endDate);

        const reqDates = [];
        for (let d = new Date(startDate); d <= endDate; d = addDays(d, CURRENT_FLOW_STEP_DAYS)) {
            reqDates.push(formatReqDate(d));
        }
        if (reqDates[reqDates.length - 1] !== baseDateStr) {
            reqDates.push(baseDateStr);
        }

        const dayMaxMap = {};
        for (let i = 0; i < reqDates.length; i += CURRENT_FLOW_FETCH_CONCURRENCY) {
            const chunk = reqDates.slice(i, i + CURRENT_FLOW_FETCH_CONCURRENCY);
            const responses = await Promise.all(chunk.map(async (reqDate) => {
                try {
                    const items = await apiCall('crntFcstTime/GetCrntFcstTimeApiService', {
                        obsCode: currentCode,
                        reqDate,
                        numOfRows: '300',
                        pageNo: '1'
                    });
                    return items;
                } catch {
                    return [];
                }
            }));

            for (const items of responses) {
                const dailyMax = collectDailyMaxSpeedsFromItems(items);
                Object.entries(dailyMax).forEach(([dateKey, maxSpeed]) => {
                    if (dateKey < startKey || dateKey > endKey) return;
                    dayMaxMap[dateKey] = maxSpeed;
                });
            }
        }

        const speeds = Object.values(dayMaxMap).filter(v => Number.isFinite(v) && v > 0).sort((a, b) => a - b);
        if (speeds.length < CURRENT_FLOW_MIN_SAMPLES) return null;

        const p10 = percentile(speeds, 0.10);
        const p90 = percentile(speeds, 0.90);
        if (!Number.isFinite(p10) || !Number.isFinite(p90) || p90 <= p10) return null;

        return {
            currentCode,
            p10: Math.round(p10 * 10) / 10,
            p90: Math.round(p90 * 10) / 10,
            sampleCount: speeds.length,
            windowStart: startKey,
            windowEnd: endKey,
            updatedAt: new Date().toISOString(),
        };
    }

    async function primeCurrentFlowStats(currentCode, dateStr) {
        if (!currentCode || !/^\d{8}$/.test(dateStr || '')) return false;
        const existing = getCurrentFlowStats(currentCode);
        if (isCurrentFlowStatsUsable(existing, dateStr)) return false;
        if (currentFlowStatsInFlight[currentCode]) return currentFlowStatsInFlight[currentCode];

        currentFlowStatsInFlight[currentCode] = (async () => {
            const stats = await buildCurrentFlowStatsForStation(currentCode, dateStr);
            if (!stats) return false;
            currentFlowStatsMemoryCache[currentCode] = stats;
            setCachedCurrentFlowStats(currentCode, stats);
            return true;
        })().catch(() => false).finally(() => {
            delete currentFlowStatsInFlight[currentCode];
        });

        return currentFlowStatsInFlight[currentCode];
    }

    function getCurrentFlowSnapshotKey(currentCode, dateStr) {
        return `${currentCode || ''}:${dateStr || ''}`;
    }

    function setCurrentFlowSnapshot(currentCode, dateStr, snapshot) {
        if (!currentCode || !/^\d{8}$/.test(dateStr || '') || !snapshot) return;
        currentFlowSnapshotCache[getCurrentFlowSnapshotKey(currentCode, dateStr)] = snapshot;
    }

    function getCurrentFlowSnapshot(currentCode, dateStr) {
        if (!currentCode || !/^\d{8}$/.test(dateStr || '')) return null;
        return currentFlowSnapshotCache[getCurrentFlowSnapshotKey(currentCode, dateStr)] || null;
    }

    function calcCurrentFlowPct(maxSpeed, currentCode, dateStr) {
        if (maxSpeed == null || !Number.isFinite(maxSpeed) || maxSpeed < 0) return null;
        const stats = getCurrentFlowStats(currentCode);
        if (isCurrentFlowStatsUsable(stats, dateStr)) {
            const normalized = ((maxSpeed - stats.p10) / (stats.p90 - stats.p10)) * 100;
            return Math.round(clamp(normalized, 0, 100));
        }
        // ì´ˆê¸° ìˆ˜ì§‘ ì „ì—ëŠ” ì ˆëŒ€ ìœ ì†ê°’(0~100cm/s)ì„ ì„ì‹œ í¼ì„¼íŠ¸ë¡œ ì‚¬ìš©
        return Math.round(clamp(maxSpeed, 0, 100));
    }

    function resolveMulddaeFlowPct(dateStr, rangePct, currentSnap, stationCode) {
        const rangeValue = Number.isFinite(rangePct) ? clamp(Math.round(rangePct), 0, 100) : null;
        const currentValue = (currentSnap && Number.isFinite(currentSnap.pct))
            ? clamp(Math.round(currentSnap.pct), 0, 100)
            : null;
        const policy = getFlowRecencyPolicy(dateStr, stationCode);

        if (currentValue == null && rangeValue == null) {
            return { pct: null, mode: 'none', sourceLabel: 'ë°ì´í„°ì—†ìŒ', policy: null };
        }
        if (policy == null) {
            if (currentValue != null) return { pct: currentValue, mode: 'current', sourceLabel: 'ìœ ì†ê¸°ë°˜', policy: null, currentWeight: 1, rangeWeight: 0 };
            return { pct: rangeValue, mode: 'range', sourceLabel: 'ì¡°ì°¨ê¸°ë°˜', policy: null, currentWeight: 0, rangeWeight: 1 };
        }

        if (policy.stage === 'far') {
            if (rangeValue != null) {
                return {
                    pct: rangeValue,
                    mode: 'range',
                    sourceLabel: 'ì¡°ì°¨ê¸°ë°˜',
                    policy,
                    currentWeight: 0,
                    rangeWeight: 1
                };
            }
            return {
                pct: currentValue,
                mode: 'current',
                sourceLabel: 'ìœ ì†ê¸°ë°˜',
                policy,
                currentWeight: 1,
                rangeWeight: 0
            };
        }

        if (currentValue != null && rangeValue != null) {
            const blended = Math.round(clamp(
                currentValue * policy.currentWeight + rangeValue * policy.rangeWeight,
                0,
                100
            ));
            const mode = policy.stage === 'near' ? 'currentWeighted' : 'hybrid';
            return {
                pct: blended,
                mode,
                sourceLabel: mode === 'hybrid' ? 'í˜¼í•©ë³´ì •' : 'ìœ ì†ê°€ì¤‘',
                policy,
                currentWeight: policy.currentWeight,
                rangeWeight: policy.rangeWeight
            };
        }

        if (currentValue != null) {
            return {
                pct: currentValue,
                mode: 'current',
                sourceLabel: 'ìœ ì†ê¸°ë°˜',
                policy,
                currentWeight: 1,
                rangeWeight: 0
            };
        }

        return {
            pct: rangeValue,
            mode: 'range',
            sourceLabel: 'ì¡°ì°¨ê¸°ë°˜',
            policy,
            currentWeight: 0,
            rangeWeight: 1
        };
    }

    function buildCurrentFlowSnapshot(items, currentCode, dateStr) {
        if (!items || items.length === 0 || !/^\d{8}$/.test(dateStr || '')) return null;
        const datePrefix = `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
        const dayItems = items.filter(i => i.predcDt && String(i.predcDt).startsWith(datePrefix));
        const src = dayItems.filter((item) => {
            const t = extractCurrentTimeLabel(item);
            return !!t && t >= '05:00' && t <= '18:00';
        });

        const speeds = [];
        for (const item of src) {
            const speed = parseFloat(item.crsp);
            if (Number.isFinite(speed) && speed >= 0) speeds.push(speed);
        }

        const maxSpeed = speeds.length > 0 ? Math.max(...speeds) : null;
        const pct = calcCurrentFlowPct(maxSpeed, currentCode, dateStr);
        return {
            currentCode,
            dateStr,
            pct,
            maxSpeed,
            sampleCount: speeds.length,
            obsvtrNm: String((src[0] || dayItems[0] || items[0])?.obsvtrNm || ''),
            updatedAt: new Date().toISOString(),
        };
    }

    function requestCurrentFlowStatsPrime(currentCode, dateStr, refreshOnUpdate = false) {
        primeCurrentFlowStats(currentCode, dateStr).then((updated) => {
            if (!updated || !refreshOnUpdate) return;
            const key = getCurrentFlowSnapshotKey(currentCode, dateStr);
            const snap = currentFlowSnapshotCache[key];
            if (snap && Number.isFinite(snap.maxSpeed)) {
                snap.pct = calcCurrentFlowPct(snap.maxSpeed, currentCode, dateStr);
                currentFlowSnapshotCache[key] = snap;
            }
            if (currentCode === getCurrentStation() && dateStr === getDateStr()) {
                renderMulddaeCardFromState();
            }
        }).catch(() => {});
    }

    function renderMulddaeCardFromState() {
        if (!mulddaeCardState) return;
        const mulddaeCard = document.getElementById('mulddaeCard');
        const mulddaeEl = document.getElementById('mulddaeInfo');
        if (!mulddaeCard || !mulddaeEl) return;

        const { dateStr, stationCode, mulddaeBase, diff, rangePct } = mulddaeCardState;
        const mulddae = { ...mulddaeBase };
        const currentCode = getCurrentStation();
        const currentSnap = getCurrentFlowSnapshot(currentCode, dateStr);
        const flowDecision = resolveMulddaeFlowPct(dateStr, rangePct, currentSnap, stationCode);
        const activePct = flowDecision.pct;
        if (activePct != null) mulddae.pct = activePct;
        window._lastMulddaePct = mulddae.pct;

        mulddaeCard.style.display = '';
        document.getElementById('mulddaeDate').textContent = `${mulddae.name} | ì–‘ë ¥ ${dateStr.substring(0,4)}.${dateStr.substring(4,6)}.${dateStr.substring(6,8)} | ìŒë ¥ ${mulddae.lunarMonth}ì›” ${mulddae.lunarDay}ì¼`;

        const desc = mulddae.num === 'ì¡°ê¸ˆ' ? 'ì†Œì¡°ê¸° â€” ì¡°ì°¨ê°€ ê°€ì¥ ì‘ê³  ë¬¼ì‚´ì´ ì•½í•©ë‹ˆë‹¤'
            : mulddae.num === 'ë¬´ì‹œ' ? 'ì¡°ê¸ˆ ì§í›„ â€” ë¬¼íë¦„ì´ ê°€ì¥ ì•½í•œ ë‚ ì…ë‹ˆë‹¤'
            : mulddae.name === 'ì‚¬ë¦¬' && mulddae.pct >= 90 ? 'ëŒ€ì¡°ê¸° â€” ì¡°ì°¨ê°€ í¬ê³  ë¬¼ì‚´ì´ ì…‰ë‹ˆë‹¤'
            : mulddae.name === 'ì‚¬ë¦¬' ? 'ì‚¬ë¦¬ ì „í›„ â€” ì¡°ì°¨ê°€ ì ì°¨ ì¤„ì–´ë“­ë‹ˆë‹¤'
            : 'ë“¤ë¬¼ â€” ì¡°ê¸ˆâ†’ì‚¬ë¦¬ ì „í™˜ê¸°, ì¡°ì°¨ê°€ ì»¤ì§€ëŠ” ì¤‘ì…ë‹ˆë‹¤';
        const speciesFit = getSpeciesByMulddae(mulddae.num, mulddae.pct);

        const pctValue = Number.isFinite(mulddae.pct) ? mulddae.pct : null;
        const pctText = pctValue != null ? `${pctValue}%` : '-';
        const fishingInfo = (window._fishingIndexInfo && window._fishingIndexInfo.reqDate === dateStr)
            ? window._fishingIndexInfo
            : null;
        let fishingText = '';

        if (fishingInfo) {
            const scoreText = Number.isFinite(fishingInfo.totalScore)
                ? `${Math.round(fishingInfo.totalScore)}ì `
                : (Number.isFinite(fishingInfo.fishingScore) ? `${Math.round(fishingInfo.fishingScore)}ì ` : '-');
            const gradeText = fishingInfo.grade ? ` ${escapeHTML(fishingInfo.grade)}` : '';
            const placeText = fishingInfo.placeName ? ` ${escapeHTML(fishingInfo.placeName)}` : '';
            const timeText = fishingInfo.baseTime ? ` ${escapeHTML(fishingInfo.baseTime)}` : '';
            const detailParts = [];
            if (Number.isFinite(fishingInfo.fishingScore)) detailParts.push(`ë‚šì‹œ ${Math.round(fishingInfo.fishingScore)}`);
            if (Number.isFinite(fishingInfo.tideScore)) detailParts.push(`ì¡°ì„ ${Math.round(fishingInfo.tideScore)}`);
            if (Number.isFinite(fishingInfo.weatherScore)) detailParts.push(`ê¸°ìƒ ${Math.round(fishingInfo.weatherScore)}`);
            if (Number.isFinite(fishingInfo.waterScore)) detailParts.push(`ìˆ˜ì˜¨ ${Math.round(fishingInfo.waterScore)}`);
            const detailText = detailParts.length > 0 ? ` Â· ${detailParts.join(' / ')}` : '';
            fishingText = `ğŸ£ ë°”ë‹¤ë‚šì‹œì§€ìˆ˜(${escapeHTML(fishingInfo.gubun || 'ì„ ìƒ')}) ${scoreText}${gradeText}${placeText}${timeText}${detailText}`;
        }

        mulddaeEl.innerHTML = `
            <div class="mulddae-row1">
                <div class="mulddae-badge" style="background:${mulddae.color}22; color:${mulddae.color};">
                    <img class="mulddae-moon" src="${getMoonPhaseIconSrc(mulddae.lunarDay)}" alt="ë‹¬">
                    <span class="mulddae-num">${mulddae.num}</span>
                </div>
                <div class="mulddae-pct-wrap">
                    <div class="mulddae-pct-head">
                        <span class="mulddae-pct-label-inline">ì˜¤ëŠ˜ì˜ ìœ ì† (05:00~18:00 ê¸°ì¤€)</span>
                        <span class="mulddae-pct-value" style="color:${mulddae.color};">${pctText}</span>
                    </div>
                    <div class="mulddae-pct-bar"><div class="mulddae-pct-bar-fill" style="width:${pctValue != null ? pctValue : 0}%;background:${mulddae.color};"></div></div>
                </div>
            </div>
            <div class="mulddae-desc">${desc}</div>
            ${fishingText ? `<div style="font-size:0.76em;color:#8fc4ff;">${fishingText}</div>` : ''}
            <div class="mulddae-species">
                ${speciesFit.map(s => `<div style="display:flex;align-items:center;gap:4px;padding:3px 8px;background:${s.color}15;border:1px solid ${s.color}33;border-radius:6px;font-size:0.78em;">
                    <span>${s.emoji}</span>
                    <span style="color:var(--text);font-weight:600;">${s.name}</span>
                    <span style="color:${s.color};font-weight:700;">${s.grade}</span>
                    <span style="color:var(--muted);font-size:0.85em;">${s.desc}</span>
                </div>`).join('')}
            </div>`;
    }

    // ==================== ì¼ì¶œ/ì¼ëª° ì²œë¬¸ê³„ì‚° (SunCalc ì•Œê³ ë¦¬ì¦˜) ====================
    // ê´€ì¸¡ì†Œ ì½”ë“œ â†’ ìœ„ë„/ê²½ë„ ë§¤í•‘
    const STATION_COORDS = {
        // ì¸ì²œ/ê²½ê¸°
        'DT_0001': [37.45, 126.59], 'DT_0052': [37.35, 126.65], 'DT_0044': [37.53, 126.57],
        'DT_0032': [37.73, 126.53], 'DT_0043': [37.25, 126.47], 'DT_0093': [37.38, 126.42],
        'DT_0065': [37.23, 126.15], 'DT_0066': [37.18, 126.20], 'DT_0002': [36.97, 126.82],
        'DT_0008': [37.18, 126.65],
        // ì¶©ë‚¨/ì „ë¶
        'DT_0050': [36.90, 126.17], 'DT_0067': [36.67, 126.13], 'DT_0017': [36.97, 126.37],
        'DT_0025': [36.40, 126.55], 'DT_0051': [36.07, 126.52], 'DT_0024': [36.00, 126.68],
        'DT_0018': [35.97, 126.72], 'DT_0068': [35.62, 126.30], 'DT_0037': [36.12, 125.85],
        // ì „ë‚¨ì„œë¶€
        'DT_0007': [34.78, 126.38], 'DT_0035': [34.68, 125.43], 'DT_0094': [34.42, 125.95],
        // ì „ë‚¨ë™ë¶€
        'DT_0028': [34.48, 127.73], 'DT_0027': [34.73, 127.75], 'DT_0026': [34.48, 127.08],
        'DT_0092': [34.57, 127.30], 'DT_0016': [34.75, 127.77], 'DT_0049': [34.30, 127.53],
        'DT_0031': [34.30, 126.52],
        // ë‚¨í•´/ê²½ë‚¨
        'DT_0061': [34.83, 128.42], 'DT_0014': [34.85, 128.43], 'DT_0003': [35.08, 128.03],
        'DT_0029': [34.92, 128.07], 'DT_0063': [34.73, 128.33], 'DT_0062': [34.80, 128.57],
        'DT_0056': [34.70, 128.73], 'DT_0013': [34.82, 128.60], 'DT_0033': [34.85, 128.43],
        'DT_0015': [34.73, 128.02], 'DT_0048': [34.75, 128.90], 'DT_0030': [34.92, 127.90],
        // ë¶€ì‚°/ìš¸ì‚°
        'DT_0005': [35.08, 129.03], 'DT_0020': [35.50, 129.38],
        // ë™í•´
        'DT_0091': [36.02, 129.57], 'DT_0039': [37.48, 129.17], 'DT_0011': [36.68, 129.48],
        'DT_0057': [37.48, 129.13], 'DT_0006': [38.20, 128.60], 'DT_0012': [37.87, 128.83],
        'DT_0019': [36.40, 129.38], 'DT_0034': [37.08, 129.40], 'DT_0036': [36.73, 129.47],
        // ì œì£¼
        'DT_0004': [33.52, 126.53], 'DT_0022': [33.47, 126.93], 'DT_0010': [33.25, 126.57],
        'DT_0023': [33.47, 126.93], 'DT_0021': [33.52, 126.25],
    };

    function getSunTimes(date, lat, lon) {
        // ì²œë¬¸ê³„ì‚° ê¸°ë°˜ ì¼ì¶œ/ì¼ëª° (NOAA ì•Œê³ ë¦¬ì¦˜ ê°„ì†Œí™”)
        const rad = Math.PI / 180;
        const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
        const lngHour = lon / 15;

        // ì¼ì¶œ/ì¼ëª° ê³„ì‚° í•¨ìˆ˜
        function calcSunTime(rising) {
            const t = rising ? dayOfYear + (6 - lngHour) / 24 : dayOfYear + (18 - lngHour) / 24;

            // íƒœì–‘ í‰ê· ê·¼ì ì´ê°
            const M = (0.9856 * t) - 3.289;

            // íƒœì–‘ í™©ê²½
            let L = M + (1.916 * Math.sin(M * rad)) + (0.020 * Math.sin(2 * M * rad)) + 282.634;
            L = ((L % 360) + 360) % 360;

            // íƒœì–‘ ì ê²½
            let RA = Math.atan(0.91764 * Math.tan(L * rad)) / rad;
            RA = ((RA % 360) + 360) % 360;

            const Lquad = Math.floor(L / 90) * 90;
            const RAquad = Math.floor(RA / 90) * 90;
            RA = RA + (Lquad - RAquad);
            RA = RA / 15;

            // íƒœì–‘ ì ìœ„
            const sinDec = 0.39782 * Math.sin(L * rad);
            const cosDec = Math.cos(Math.asin(sinDec));

            // ì‹œê°„ê° (ì¼ì¶œ/ì¼ëª°: -0.833ë„ = ëŒ€ê¸°êµ´ì ˆ ë³´ì •)
            const zenith = 90.833;
            const cosH = (Math.cos(zenith * rad) - (sinDec * Math.sin(lat * rad))) / (cosDec * Math.cos(lat * rad));

            if (cosH > 1 || cosH < -1) return null; // ê·¹ì§€ë°© ì²˜ë¦¬

            let H = rising
                ? (360 - Math.acos(cosH) / rad) / 15
                : Math.acos(cosH) / rad / 15;

            const T = H + RA - (0.06571 * t) - 6.622;
            let UT = ((T - lngHour) % 24 + 24) % 24;

            // KST (UTC+9)
            let KST = UT + 9;
            if (KST >= 24) KST -= 24;

            const hours = Math.floor(KST);
            const minutes = Math.round((KST - hours) * 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        return {
            sunrise: calcSunTime(true),
            sunset: calcSunTime(false)
        };
    }

    function getSunTimesForStation(dateStr, stationCode) {
        // FISHING_PORTSì—ì„œ í˜„ì¬ ê´€ì¸¡ì†Œì— ë§¤ì¹­ë˜ëŠ” í¬íŠ¸ ì¢Œí‘œ ìš°ì„ , ì—†ìœ¼ë©´ STATION_COORDS ì‚¬ìš©
        const port = FISHING_PORTS.find(p => p.station === stationCode);
        let lat, lon;
        if (port) {
            lat = port.lat;
            lon = port.lon;
        } else if (STATION_COORDS[stationCode]) {
            [lat, lon] = STATION_COORDS[stationCode];
        } else {
            // fallback: ì„œìš¸ ê¸°ì¤€
            lat = 37.5; lon = 126.97;
        }

        const y = parseInt(dateStr.substring(0, 4));
        const m = parseInt(dateStr.substring(4, 6)) - 1;
        const d = parseInt(dateStr.substring(6, 8));
        return getSunTimes(new Date(y, m, d), lat, lon);
    }

    // ==================== GENERIC API CALL (Worker í”„ë¡ì‹œ ê²½ìœ ) ====================
    const PROXY_ENDPOINT_MAP = {
        'tideFcstHghLw/GetTideFcstHghLwApiService': '/api/tide-hilo',
        'surveyTideLevel/GetSurveyTideLevelApiService': '/api/tide-level',
        'crntFcstTime/GetCrntFcstTimeApiService': '/api/current',
        'tideFcstTime/GetTideFcstTimeApiService': '/api/tide-time',
        'deviationCal/GetDeviationCalApiService': '/api/deviation',
        'lsTermTideObs/GetLsTermTideObsApiService': '/api/ls-term-tide-obs',
        'tidebed/GetTideBedPreApiService': '/api/tidebed',
        'crntFcstFldEbb/GetCrntFcstFldEbbApiService': '/api/current-fld-ebb',
        'fcstFishingv2/GetFcstFishingApiServicev2': '/api/fishing-index',
    };

    async function apiCall(path, params) {
        const endpoint = PROXY_ENDPOINT_MAP[path];
        if (!endpoint) throw new Error(`Unknown API path: ${path}`);

        const url = new URL(`${API_BASE}${endpoint}`);
        Object.entries(params || {}).forEach(([k, v]) => {
            if (v == null || v === '') return;
            url.searchParams.set(k, String(v));
        });

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        let resp;
        try {
            resp = await fetch(url.toString(), { signal: controller.signal });
        } finally { clearTimeout(timeoutId); }
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const ct = resp.headers.get('content-type') || '';
        if (!ct.includes('json')) throw new Error('ì˜ëª»ëœ ì‘ë‹µ í˜•ì‹');
        const json = await resp.json();

        const resultCode = json?.header?.resultCode || json?.response?.header?.resultCode || null;
        const resultMsg = json?.header?.resultMsg || json?.response?.header?.resultMsg || null;
        if (resultCode && resultCode !== '00') {
            throw new Error(resultMsg || 'API ì˜¤ë¥˜');
        }
        const items = json?.body?.items?.item
            || json?.response?.body?.items?.item
            || json?.result?.data
            || [];
        return Array.isArray(items) ? items : [items];
    }

    async function apiCallRaw(endpoint, params) {
        const url = new URL(`${API_BASE}${endpoint}`);
        Object.entries(params || {}).forEach(([k, v]) => {
            if (v == null || v === '') return;
            url.searchParams.set(k, String(v));
        });

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        let resp;
        try {
            resp = await fetch(url.toString(), { signal: controller.signal });
        } finally { clearTimeout(timeoutId); }
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const ct = resp.headers.get('content-type') || '';
        if (!ct.includes('json')) throw new Error('ì˜ëª»ëœ ì‘ë‹µ í˜•ì‹');
        return await resp.json();
    }

    // ==================== FETCH ALL ====================
    async function fetchAll() {
        const btn = document.getElementById('searchBtn');
        btn.disabled = true;
        let chartLoadDone = false;
        setTideChartLoadStatus('loading');
        try {
            const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('ìš”ì²­ ì‹œê°„ ì´ˆê³¼')), 30000));
            await Promise.race([
                (async () => {
                    await Promise.all([fetchTideHighLow(), fetchCurrentData()]);
                    await fetchTidePrediction();
                    renderCombinedChart();
                })(),
                timeout
            ]);
            chartLoadDone = true;
        } catch(e) {
            console.error(e);
            if (e.message === 'ìš”ì²­ ì‹œê°„ ì´ˆê³¼') {
                const summaryEl = document.getElementById('tideSummary');
                if (summaryEl) summaryEl.innerHTML = '<div class="error-msg">ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.</div>';
            }
            setTideChartLoadStatus('error');
        }
        finally {
            if (chartLoadDone) setTideChartLoadStatus('done');
            btn.disabled = false;
            btn.textContent = 'ì¡°íšŒ';
        }
    }

    // ==================== 1) ê³ ì €ì¡° (tideFcstHghLw) ====================
    async function fetchTideHighLow() {
        const summaryEl = document.getElementById('tideSummary');
        summaryEl.innerHTML = '<div class="loading"><div class="spinner"></div><div>ê³ ì €ì¡° ë°ì´í„° ë¡œë”©...</div></div>';
        setTideDataStamp('ì˜ˆë³´ ìƒì„±ì‹œê° ì¡°íšŒ ì¤‘ Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° ì¡°íšŒ ì¤‘');

        try {
            const stationCode = getStation();
            const dateStr = getDateStr();
            window._fishingIndexInfo = null;
            const items = await apiCall('tideFcstHghLw/GetTideFcstHghLwApiService', {
                obsCode: stationCode,
                reqDate: dateStr,
                numOfRows: '20',
                pageNo: '1'
            });
            const deviationPromise = apiCall('deviationCal/GetDeviationCalApiService', {
                obsCode: stationCode,
                reqDate: dateStr,
                numOfRows: '50',
                pageNo: '1'
            }).then(parseDeviationText).catch(() => '');
            const lsTermObsItemsPromise = apiCall('lsTermTideObs/GetLsTermTideObsApiService', {
                obsCode: stationCode,
                reqDate: dateStr,
                numOfRows: '24',
                pageNo: '1'
            }).catch(() => []);
            const harmonicsPromise = apiCallRaw('/api/khoa/tide-harmonics', {
                obsCode: stationCode
            }).then(parseTideHarmonicsText).catch(() => '');
            const fishingPromise = fetchFishingIndexInfo(stationCode, dateStr).catch(() => null);

            if (!items || items.length === 0) {
                setTideDataStamp('ì˜ˆë³´ ìƒì„±ì‹œê° - Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° -');
                summaryEl.innerHTML = '<div class="error-msg">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            requestFlowStatsPrime(stationCode, dateStr, true);
            const datePrefix = `${dateStr.substring(0,4)}-${dateStr.substring(4,6)}-${dateStr.substring(6,8)}`;
            const todayItems = items.filter(i => i.predcDt && i.predcDt.startsWith(datePrefix));
            const displayItems = todayItems.length > 0 ? todayItems : items.slice(0, 4);
            const filteredItems = displayItems.filter(i => {
                const time = i.predcDt.substring(11, 16);
                return time >= '05:00' && time <= '18:00';
            });

            const highs = filteredItems.filter(i => parseInt(i.extrSe) % 2 === 1 && i.predcTdlvVl != null);
            const lows = filteredItems.filter(i => parseInt(i.extrSe) % 2 === 0 && i.predcTdlvVl != null);

            const maxHigh = highs.length > 0 ? Math.max(...highs.map(h => parseFloat(h.predcTdlvVl))) : null;
            const minLow = lows.length > 0 ? Math.min(...lows.map(l => l.predcTdlvVl)) : null;
            const diff = (maxHigh !== null && minLow !== null) ? maxHigh - minLow : null;

            const bestHigh = highs.length > 0 ? highs.reduce((a, b) => a.predcTdlvVl > b.predcTdlvVl ? a : b) : null;
            const bestLow = lows.length > 0 ? lows.reduce((a, b) => a.predcTdlvVl < b.predcTdlvVl ? a : b) : null;

            // ë¬¼ë•Œ ì¹´ë“œ: ì£¼ì§€í‘œëŠ” ìœ ì†(crsp), ì¡°ì°¨ê¸°ë°˜ì€ ë³´ì¡°ì§€í‘œë¡œ í•¨ê»˜ í‘œì‹œ
            const rangePct = calcRangeFlowPct(diff, stationCode, dateStr);
            mulddaeCardState = {
                dateStr,
                stationCode,
                mulddaeBase: getMulddaeInfo(dateStr),
                diff,
                rangePct
            };
            renderMulddaeCardFromState();
            const [deviationText, lsTermObsItems, harmonicsText, fishingInfo] = await Promise.all([
                deviationPromise,
                lsTermObsItemsPromise,
                harmonicsPromise,
                fishingPromise
            ]);
            const lsTermObsText = parseLsTermObsText(lsTermObsItems);
            setTideDataStamp(buildTideDataStampText(items, lsTermObsItems, dateStr));
            window._fishingIndexInfo = fishingInfo;
            renderMulddaeCardFromState();
            // ì¼ì¶œ/ì¼ëª° ê³„ì‚°
            const sunTimes = getSunTimesForStation(dateStr, stationCode);

            summaryEl.innerHTML = `
                <div class="tide-summary">
                    <div class="tide-item high">
                        <div class="label">ìµœê³ ì¡°ìœ„</div>
                        <div class="value">${maxHigh !== null ? maxHigh.toFixed(0) : '-'}<small style="font-size:0.4em"> cm</small></div>
                        <div class="time">${bestHigh ? bestHigh.predcDt.substring(11, 16) : '-'}</div>
                    </div>
                    <div class="tide-item low">
                        <div class="label">ìµœì €ì¡°ìœ„</div>
                        <div class="value">${minLow !== null ? minLow.toFixed(0) : '-'}<small style="font-size:0.4em"> cm</small></div>
                        <div class="time">${bestLow ? bestLow.predcDt.substring(11, 16) : '-'}</div>
                    </div>
                    <div class="tide-item diff">
                        <div class="label">ì¡°ì°¨ (ê³ ì €ì°¨)</div>
                        <div class="value">${diff !== null ? diff.toFixed(0) : '-'}<small style="font-size:0.4em"> cm</small></div>
                        <div class="time">${[deviationText, lsTermObsText, harmonicsText].filter(Boolean).join(' Â· ')}</div>
                    </div>
                </div>`;

            window._hlData = displayItems;
        } catch(e) {
            setTideDataStamp('ì˜ˆë³´ ìƒì„±ì‹œê° - Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° -');
            summaryEl.innerHTML = `<div class="error-msg">ê³ ì €ì¡° ì˜¤ë¥˜: ${escapeHTML(e.message)}</div>`;
        }
    }

    // ==================== 2) 10ë¶„ ë‹¨ìœ„ ì¡°ìœ„ ê·¸ë˜í”„ (surveyTideLevel) ====================
    // ê³ ì €ì¡° í¬ì¸íŠ¸ ì‚¬ì´ë¥¼ ì½”ì‚¬ì¸ ë³´ê°„ìœ¼ë¡œ ì—°ê²°í•˜ì—¬ ì˜ˆì¸¡ ê³¡ì„  ìƒì„±
    function interpolateFromHiLo(hlData) {
        if (!hlData || hlData.length < 2) return { labels: [], predicted: [] };

        // ê³ ì €ì¡° í¬ì¸íŠ¸ë¥¼ ë¶„ ë‹¨ìœ„ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ë³€í™˜
        const points = hlData.map(item => {
            const time = item.predcDt.substring(11, 16);
            const [h, m] = time.split(':').map(Number);
            return { min: h * 60 + m, val: item.predcTdlvVl };
        }).sort((a, b) => a.min - b.min);

        // 10ë¶„ ê°„ê²©ìœ¼ë¡œ 00:00~23:50 ë¼ë²¨ ìƒì„±
        const labels = [];
        const predicted = [];
        for (let t = 0; t < 24 * 60; t += 10) {
            const hh = String(Math.floor(t / 60)).padStart(2, '0');
            const mm = String(t % 60).padStart(2, '0');
            labels.push(`${hh}:${mm}`);

            // í˜„ì¬ ì‹œê°ì´ ì–´ëŠ ë‘ í¬ì¸íŠ¸ ì‚¬ì´ì— ìˆëŠ”ì§€ ì°¾ê¸°
            let val = null;
            if (t <= points[0].min) {
                // ì²« í¬ì¸íŠ¸ ì´ì „: ì²« í¬ì¸íŠ¸ ê°’ ìœ ì§€
                val = points[0].val;
            } else if (t >= points[points.length - 1].min) {
                // ë§ˆì§€ë§‰ í¬ì¸íŠ¸ ì´í›„: ë§ˆì§€ë§‰ ê°’ ìœ ì§€
                val = points[points.length - 1].val;
            } else {
                for (let i = 0; i < points.length - 1; i++) {
                    if (t >= points[i].min && t <= points[i + 1].min) {
                        const ratio = (t - points[i].min) / (points[i + 1].min - points[i].min);
                        // ì½”ì‚¬ì¸ ë³´ê°„: ìì—°ìŠ¤ëŸ¬ìš´ ì¡°ìœ„ ê³¡ì„ 
                        const cosRatio = (1 - Math.cos(ratio * Math.PI)) / 2;
                        val = points[i].val + (points[i + 1].val - points[i].val) * cosRatio;
                        break;
                    }
                }
            }
            predicted.push(val !== null ? Math.round(val * 10) / 10 : null);
        }
        return { labels, predicted };
    }

    function toFiniteNumber(v) {
        const n = parseFloat(v);
        return Number.isFinite(n) ? n : null;
    }

    function normalizeClockTime(raw) {
        if (raw == null) return null;
        const s = String(raw).trim();
        if (!s) return null;

        let m = s.match(/(\d{2}):(\d{2})/);
        if (m) return `${m[1]}:${m[2]}`;

        // YYYYMMDDHHMM[SS] í˜•íƒœ
        m = s.match(/(?:^|\D)\d{8}(\d{2})(\d{2})(?:\d{2})?(?:\D|$)/);
        if (m) return `${m[1]}:${m[2]}`;

        // HHMM í˜•íƒœ(ë‹¤ë¥¸ ìˆ«ìì—´ ì‚¬ì´ê°€ ì•„ë‹Œ í† í°)
        m = s.match(/(?:^|\D)(\d{2})(\d{2})(?:\D|$)/);
        if (m) return `${m[1]}:${m[2]}`;

        // ...HHMM ìœ¼ë¡œ ëë‚˜ëŠ” ê¸´ ìˆ«ìì—´ fallback
        m = s.match(/(\d{2})(\d{2})(?:\d{2})?$/);
        if (m) return `${m[1]}:${m[2]}`;

        const short = s.match(/^(\d{1,2}):(\d{2})$/);
        if (short) return `${String(parseInt(short[1], 10)).padStart(2, '0')}:${short[2]}`;

        return null;
    }

    function extractCurrentTimeLabel(item) {
        if (!item || typeof item !== 'object') return null;

        const direct = normalizeClockTime(extractByKeysCaseInsensitive(item, [
            'predcDt', 'predcTm', 'predcTime', 'tm', 'dateTime', 'obsrvnDt'
        ]));
        if (direct) return direct;

        const keys = Object.keys(item);
        for (const k of keys) {
            const lk = k.toLowerCase();
            if (!(lk.includes('pred') || lk.includes('obs'))) continue;
            if (!(lk.includes('dt') || lk.endsWith('tm') || lk.includes('time'))) continue;
            const t = normalizeClockTime(item[k]);
            if (t) return t;
        }
        for (const k of keys) {
            const lk = k.toLowerCase();
            if (!(lk.includes('dt') || lk.endsWith('tm') || lk.includes('time'))) continue;
            const t = normalizeClockTime(item[k]);
            if (t) return t;
        }
        return null;
    }

    function dedupeCurrentItems(items) {
        const seen = new Set();
        const out = [];
        (items || []).forEach((item, idx) => {
            const t = extractCurrentTimeLabel(item);
            const s = toFiniteNumber(extractByKeysCaseInsensitive(item, ['crsp', 'speed', 'spd']));
            const d = extractByKeysCaseInsensitive(item, ['crdir', 'direction', 'dir']) || '';
            const key = t
                ? `${t}|${Number.isFinite(s) ? s.toFixed(3) : ''}|${String(d)}`
                : `idx:${idx}`;
            if (seen.has(key)) return;
            seen.add(key);
            out.push(item);
        });
        return out;
    }

    function parseDateTimeToken(raw, fallbackDateStr = '') {
        if (raw == null) return null;
        const s = String(raw).trim();
        if (!s) return null;

        let m = s.match(/(\d{4})[-./]?(\d{2})[-./]?(\d{2})[ T]?(\d{2}):?(\d{2})(?::?(\d{2}))?/);
        if (m) {
            const y = m[1];
            const mo = m[2];
            const d = m[3];
            const h = m[4];
            const mi = m[5];
            const sec = m[6] || '00';
            return {
                sortKey: Number(`${y}${mo}${d}${h}${mi}${sec}`),
                dateLabel: `${y}.${mo}.${d}`,
                timeLabel: `${h}:${mi}`,
                fullLabel: `${y}.${mo}.${d} ${h}:${mi}`
            };
        }

        m = s.match(/(?:^|\D)(\d{8})(\d{4})(\d{0,2})(?:\D|$)/);
        if (m) {
            const ymd = m[1];
            const hm = m[2];
            const sec = (m[3] || '00').padStart(2, '0');
            const y = ymd.substring(0, 4);
            const mo = ymd.substring(4, 6);
            const d = ymd.substring(6, 8);
            const h = hm.substring(0, 2);
            const mi = hm.substring(2, 4);
            return {
                sortKey: Number(`${y}${mo}${d}${h}${mi}${sec}`),
                dateLabel: `${y}.${mo}.${d}`,
                timeLabel: `${h}:${mi}`,
                fullLabel: `${y}.${mo}.${d} ${h}:${mi}`
            };
        }

        const t = normalizeClockTime(s);
        if (t && /^\d{8}$/.test(fallbackDateStr || '')) {
            const y = fallbackDateStr.substring(0, 4);
            const mo = fallbackDateStr.substring(4, 6);
            const d = fallbackDateStr.substring(6, 8);
            const h = t.substring(0, 2);
            const mi = t.substring(3, 5);
            return {
                sortKey: Number(`${y}${mo}${d}${h}${mi}00`),
                dateLabel: `${y}.${mo}.${d}`,
                timeLabel: `${h}:${mi}`,
                fullLabel: `${y}.${mo}.${d} ${h}:${mi}`
            };
        }
        return null;
    }

    function pickLatestDateTimeFromItems(items, keys, fallbackDateStr = '') {
        if (!items || items.length === 0) return null;
        let best = null;
        for (const item of items) {
            const raw = extractByKeysCaseInsensitive(item, keys);
            const parsed = parseDateTimeToken(raw, fallbackDateStr);
            if (!parsed) continue;
            if (!best || parsed.sortKey > best.sortKey) best = parsed;
        }
        return best;
    }

    function buildTideDataStampText(hlItems, lsTermItems, dateStr) {
        const forecastRef = pickLatestDateTimeFromItems(
            lsTermItems,
            ['predcDt', 'predcTm', 'predcTime', 'baseTime', 'tm'],
            dateStr
        ) || pickLatestDateTimeFromItems(
            hlItems,
            ['predcDt', 'predcTm', 'predcTime', 'tm'],
            dateStr
        );

        const observedRef = pickLatestDateTimeFromItems(
            lsTermItems,
            ['obsrvnDt', 'obsrvnTm', 'obsrvnTime', 'tm'],
            dateStr
        );

        const forecastText = forecastRef ? forecastRef.timeLabel : '-';
        const observedText = observedRef ? observedRef.timeLabel : '-';
        return `ì˜ˆë³´ ìƒì„±ì‹œê° ${forecastText} Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° ${observedText}`;
    }

    function setTideDataStamp(text) {
        const el = document.getElementById('tideDataStamp');
        if (!el) return;
        el.textContent = text || 'ì˜ˆë³´ ìƒì„±ì‹œê° - Â· ì‹¤ì¸¡ ë°˜ì˜ì‹œê° -';
    }

    function setTideChartLoadStatus(state, text) {
        const wrap = document.getElementById('tideChartLoadStatus');
        const label = document.getElementById('tideChartLoadText');
        const btn = document.getElementById('tideChartReloadBtn');
        if (!wrap || !label) return;

        wrap.classList.remove('is-loading', 'is-done', 'is-error');

        const statusMap = {
            idle: text || 'ëŒ€ê¸°',
            loading: text || 'ë¡œë”©ì¤‘...',
            done: text || 'ë¡œë”©ì™„ë£Œ',
            error: text || 'ë¡œë”©ì‹¤íŒ¨'
        };
        label.textContent = statusMap[state] || statusMap.idle;

        if (state === 'loading') wrap.classList.add('is-loading');
        else if (state === 'done') wrap.classList.add('is-done');
        else if (state === 'error') wrap.classList.add('is-error');

        if (btn) {
            const isLoading = state === 'loading';
            btn.disabled = isLoading;
            btn.classList.toggle('is-spinning', isLoading);
        }
    }

    async function refreshTideChart() {
        if (tideChartReloading) return;
        tideChartReloading = true;
        setTideChartLoadStatus('loading');
        try {
            const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('ìš”ì²­ ì‹œê°„ ì´ˆê³¼')), 30000));
            await Promise.race([
                (async () => {
                    await fetchTideHighLow();
                    await fetchTidePrediction();
                    renderCombinedChart();
                })(),
                timeout
            ]);
            setTideChartLoadStatus('done');
        } catch (e) {
            console.error('ê·¸ë˜í”„ ìƒˆë¡œê³ ì¹¨ ì˜¤ë¥˜:', e);
            setTideChartLoadStatus('error');
        } finally {
            tideChartReloading = false;
        }
    }

    function extractByKeysCaseInsensitive(obj, keys) {
        if (!obj || !keys || keys.length === 0) return null;
        const keyMap = {};
        Object.keys(obj).forEach((k) => { keyMap[k.toLowerCase()] = k; });

        for (const key of keys) {
            if (obj[key] != null && obj[key] !== '') return obj[key];
            const real = keyMap[String(key).toLowerCase()];
            if (real && obj[real] != null && obj[real] !== '') return obj[real];
        }
        return null;
    }

    function buildTimeSeriesMap(items, timeKeys, valueKeys) {
        const map = {};
        (items || []).forEach((item) => {
            const tRaw = extractByKeysCaseInsensitive(item, timeKeys);
            const vRaw = extractByKeysCaseInsensitive(item, valueKeys);
            const time = normalizeClockTime(tRaw);
            const val = toFiniteNumber(vRaw);
            if (!time || val == null) return;
            map[time] = Math.round(val * 10) / 10;
        });
        return map;
    }

    function mergePredictedWithSeriesMap(labels, predicted, seriesMap) {
        if (!labels || labels.length === 0) return predicted;
        const keys = Object.keys(seriesMap || {});
        if (keys.length === 0) return predicted;
        return labels.map((lbl, idx) => (seriesMap[lbl] != null ? seriesMap[lbl] : predicted[idx]));
    }

    function buildLabelsAndPredictedFromSeriesMap(seriesMap) {
        const keys = Object.keys(seriesMap || {}).sort();
        if (keys.length === 0) return { labels: [], predicted: [] };
        return {
            labels: keys,
            predicted: keys.map((k) => seriesMap[k]),
        };
    }

    function parseFldEbbSummary(items) {
        if (!items || items.length === 0) return null;
        const rec = items[0] || {};

        const fldTime = normalizeClockTime(extractByKeysCaseInsensitive(rec, [
            'fldTm', 'fldTime', 'floodTm', 'floodTime', 'maxFldTm', 'maxFloodTm', 'maxFloodTime', 'fldDt'
        ]));
        const ebbTime = normalizeClockTime(extractByKeysCaseInsensitive(rec, [
            'ebbTm', 'ebbTime', 'maxEbbTm', 'maxEbbTime', 'ebbDt'
        ]));
        const fldSpeed = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'fldSpd', 'fldSpeed', 'floodSpd', 'floodSpeed', 'maxFldSpd', 'maxFloodSpd'
        ]));
        const ebbSpeed = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'ebbSpd', 'ebbSpeed', 'maxEbbSpd'
        ]));

        if (!fldTime && !ebbTime && fldSpeed == null && ebbSpeed == null) return null;
        return { fldTime, ebbTime, fldSpeed, ebbSpeed };
    }

    function parseDeviationText(items) {
        if (!items || items.length === 0) return '';
        const rec = items[0] || {};

        let raw = extractByKeysCaseInsensitive(rec, [
            'deviation', 'deviationVal', 'deviationVl', 'devVal', 'devVl', 'dev'
        ]);
        if (raw == null) {
            for (const k of Object.keys(rec)) {
                const lk = k.toLowerCase();
                if (lk.includes('devi') || lk.startsWith('dev')) {
                    raw = rec[k];
                    break;
                }
            }
        }
        const v = toFiniteNumber(raw);
        if (v == null) return '';
        const rounded = Math.round(v);
        const sign = rounded > 0 ? '+' : '';
        return `í¸ì°¨ ${sign}${rounded}cm`;
    }

    function parseLsTermObsText(items) {
        if (!items || items.length === 0) return '';
        const rec = items[0] || {};

        const obs = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'obsrvnTdlvVl', 'obsrvnVal', 'obsVal', 'obsrvnHgt', 'tdlvHgt'
        ]));
        const pred = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'predcTdlvVl', 'predcVal', 'predVal', 'bscTdlvHgt'
        ]));
        const dt = extractByKeysCaseInsensitive(rec, [
            'obsrvnDt', 'predcDt', 'baseTime', 'tm'
        ]);
        const tm = normalizeClockTime(dt);

        if (obs != null && pred != null) {
            const delta = Math.round((obs - pred) * 10) / 10;
            const sign = delta > 0 ? '+' : '';
            return `ì¥ë‹¨ê¸°ê´€ì¸¡ ${tm ? tm + ' ' : ''}${sign}${delta}cm`;
        }
        if (obs != null) return `ì¥ë‹¨ê¸°ê´€ì¸¡ ${tm ? tm + ' ' : ''}${Math.round(obs)}cm`;
        if (pred != null) return `ì¥ë‹¨ê¸°ê´€ì¸¡ì˜ˆì¸¡ ${tm ? tm + ' ' : ''}${Math.round(pred)}cm`;
        return '';
    }

    function parseTideHarmonicsText(raw) {
        if (!raw) return '';
        const base = raw.result?.data != null ? raw.result.data : raw;
        const rows = Array.isArray(base)
            ? base
            : (Array.isArray(base?.data) ? base.data : (base && typeof base === 'object' ? [base] : []));
        if (!rows || rows.length === 0) return '';

        const normalized = rows.map((row) => {
            const nameRaw = extractByKeysCaseInsensitive(row, ['hc_name', 'hcName', 'constituent', 'name']);
            const amp = toFiniteNumber(extractByKeysCaseInsensitive(row, ['amp', 'amplitude', 'ampl']));
            const name = nameRaw == null ? '' : String(nameRaw).trim().toUpperCase();
            return { name, amp };
        }).filter((r) => r.name && Number.isFinite(r.amp));
        if (normalized.length === 0) return '';

        const byName = new Map();
        normalized.forEach((r) => {
            if (!byName.has(r.name)) byName.set(r.name, r);
        });

        const preferred = ['M2', 'S2', 'K1', 'O1'];
        const picked = [];
        preferred.forEach((key) => {
            const hit = byName.get(key);
            if (hit) picked.push(hit);
        });

        if (picked.length === 0) {
            normalized.sort((a, b) => b.amp - a.amp);
            normalized.slice(0, 4).forEach((r) => picked.push(r));
        }
        if (picked.length === 0) return '';

        const text = picked.map((r) => `${r.name} ${r.amp.toFixed(2)}`).join(' ');
        return `ì¡°í™” ${text}`;
    }

    function getActiveFishingPlaceName(stationCode) {
        if (window._selectedPort && window._selectedPort.name) return window._selectedPort.name;
        const byStation = FISHING_PORTS.find((p) => p.station === stationCode);
        if (byStation && byStation.name) return byStation.name;
        let stationName = '';
        for (const r of REGIONS) {
            const hit = r.stations.find((s) => s[0] === stationCode);
            if (hit) { stationName = hit[1]; break; }
        }
        return stationName || '';
    }

    function parseFishingIndexInfo(items, gubun, placeName, reqDate) {
        if (!items || items.length === 0) return null;
        const rec = items[0] || {};

        const totalScore = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'total_score', 'totalScore', 'score', 'fishScore', 'fishingScore', 'fshnIdx'
        ]));
        const fishingScore = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'fishing_score', 'fishingScore', 'fish_score', 'fishScore'
        ]));
        const tideScore = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'tide_score', 'tideScore'
        ]));
        const weatherScore = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'weather_score', 'weatherScore'
        ]));
        const waterScore = toFiniteNumber(extractByKeysCaseInsensitive(rec, [
            'water_score', 'waterScore'
        ]));

        let grade = extractByKeysCaseInsensitive(rec, [
            'idxGrade', 'grade', 'step', 'fishingGrade', 'fshnStep', 'fishingIndex'
        ]);
        if (!grade && Number.isFinite(totalScore)) {
            if (totalScore >= 80) grade = 'ë§¤ìš°ì¢‹ìŒ';
            else if (totalScore >= 65) grade = 'ì¢‹ìŒ';
            else if (totalScore >= 50) grade = 'ë³´í†µ';
            else grade = 'ì£¼ì˜';
        }

        const place = extractByKeysCaseInsensitive(rec, ['placeName', 'placeNm', 'spotName', 'spotNm']) || placeName;
        const baseTimeRaw = extractByKeysCaseInsensitive(rec, ['baseTime', 'time', 'predcTime', 'tm']);
        const baseTime = normalizeClockTime(baseTimeRaw);

        if (!Number.isFinite(totalScore) && !Number.isFinite(fishingScore) && !grade) return null;

        return {
            reqDate,
            gubun,
            placeName: place || placeName || '',
            grade: grade ? String(grade) : '',
            totalScore,
            fishingScore,
            tideScore,
            weatherScore,
            waterScore,
            baseTime: baseTime || '',
        };
    }

    async function fetchFishingIndexInfo(stationCode, dateStr) {
        const gubun = 'ì„ ìƒ';
        const placeName = getActiveFishingPlaceName(stationCode);
        const items = await apiCall('fcstFishingv2/GetFcstFishingApiServicev2', {
            reqDate: dateStr,
            gubun,
            placeName,
            include: 'total_score,fishing_score,tide_score,weather_score,water_score',
            numOfRows: '20',
            pageNo: '1'
        });
        return parseFishingIndexInfo(items, gubun, placeName, dateStr);
    }

    function pad2(n) {
        return String(Math.max(0, Math.floor(n))).padStart(2, '0');
    }

    function getActiveGeoPoint(stationCode) {
        const selectedPort = window._selectedPort;
        if (selectedPort && Number.isFinite(selectedPort.lat) && Number.isFinite(selectedPort.lon)) {
            return { lat: selectedPort.lat, lon: selectedPort.lon, name: selectedPort.name };
        }

        const portByStation = FISHING_PORTS.find((p) => p.station === stationCode);
        if (portByStation && Number.isFinite(portByStation.lat) && Number.isFinite(portByStation.lon)) {
            return { lat: portByStation.lat, lon: portByStation.lon, name: portByStation.name };
        }

        if (STATION_COORDS[stationCode]) {
            return { lat: STATION_COORDS[stationCode][0], lon: STATION_COORDS[stationCode][1], name: stationCode };
        }
        return null;
    }

    function getKhoaAreaQueryTime(dateStr) {
        const nowDateStr = getDateStr();
        if (dateStr === nowDateStr) {
            const now = new Date();
            const h = now.getHours();
            const m = Math.floor(now.getMinutes() / 10) * 10;
            return { hour: pad2(h), minute: pad2(m), label: `${pad2(h)}:${pad2(m)}` };
        }
        return { hour: '12', minute: '00', label: '12:00' };
    }

    function getKhoaAreaBounds(lat, lon) {
        const dLat = 0.10;
        const rad = lat * Math.PI / 180;
        const cosv = Math.max(Math.cos(rad), 0.35);
        const dLon = dLat / cosv;
        return {
            minX: (lon - dLon).toFixed(4),
            maxX: (lon + dLon).toFixed(4),
            minY: (lat - dLat).toFixed(4),
            maxY: (lat + dLat).toFixed(4),
        };
    }

    function findNumericValue(obj, preferredKeys, matcher) {
        if (!obj) return null;
        for (const key of preferredKeys || []) {
            const raw = extractByKeysCaseInsensitive(obj, [key]);
            const v = toFiniteNumber(raw);
            if (v != null) return { value: v, key };
        }
        for (const [k, raw] of Object.entries(obj)) {
            const lk = k.toLowerCase();
            if (!matcher(lk)) continue;
            const v = toFiniteNumber(raw);
            if (v != null) return { value: v, key: k };
        }
        return null;
    }

    function detectSpeedUnit(keyName) {
        const k = String(keyName || '').toLowerCase();
        if (k.includes('knot') || k.includes('kn')) return 'kn';
        if (k.includes('cm')) return 'cm/s';
        if (k.includes('mps') || k.includes('m_s') || k.includes('meter')) return 'm/s';
        return '';
    }

    function degToCompass(deg) {
        if (!Number.isFinite(deg)) return '';
        const dirs = ['ë¶', 'ë¶ë¶ë™', 'ë¶ë™', 'ë™ë¶ë™', 'ë™', 'ë™ë‚¨ë™', 'ë‚¨ë™', 'ë‚¨ë‚¨ë™', 'ë‚¨', 'ë‚¨ë‚¨ì„œ', 'ë‚¨ì„œ', 'ì„œë‚¨ì„œ', 'ì„œ', 'ì„œë¶ì„œ', 'ë¶ì„œ', 'ë¶ë¶ì„œ'];
        const idx = Math.round((((deg % 360) + 360) % 360) / 22.5) % 16;
        return dirs[idx];
    }

    function normalizeKhoaAreaRecords(raw) {
        if (!raw) return [];
        const base = raw.result?.data != null ? raw.result.data : raw;
        if (Array.isArray(base)) return base;
        if (Array.isArray(base?.features)) return base.features;
        if (Array.isArray(base?.data)) return base.data;
        if (Array.isArray(raw.features)) return raw.features;
        return [];
    }

    function parseKhoaAreaSummary(raw) {
        const records = normalizeKhoaAreaRecords(raw);
        if (!records || records.length === 0) return null;

        const speeds = [];
        const dirs = [];
        const units = [];

        for (const rec0 of records) {
            const rec = rec0 && rec0.properties ? rec0.properties : rec0;
            if (!rec || typeof rec !== 'object') continue;

            const speedHit = findNumericValue(
                rec,
                ['crsp', 'speed', 'current_speed', 'spd', 'velocity', 'vel', 'vSpd', 'currSpd'],
                (lk) => (lk.includes('speed') || lk.includes('spd') || lk.includes('vel') || lk.includes('crsp')) && !lk.includes('dir')
            );
            const dirHit = findNumericValue(
                rec,
                ['crdir', 'direction', 'dir', 'current_dir', 'currDir'],
                (lk) => lk.includes('dir') || lk.includes('direction')
            );
            const uHit = findNumericValue(
                rec,
                ['u', 'u_component', 'uComp', 'eastVel'],
                (lk) => lk === 'u' || lk.includes('ucomp') || lk.includes('east')
            );
            const vHit = findNumericValue(
                rec,
                ['v', 'v_component', 'vComp', 'northVel'],
                (lk) => lk === 'v' || lk.includes('vcomp') || lk.includes('north')
            );

            let speedVal = speedHit ? speedHit.value : null;
            let dirDeg = dirHit ? dirHit.value : null;

            if (speedVal == null && uHit && vHit) {
                speedVal = Math.sqrt(uHit.value * uHit.value + vHit.value * vHit.value);
            }
            if (!Number.isFinite(dirDeg) && uHit && vHit) {
                dirDeg = (Math.atan2(uHit.value, vHit.value) * 180 / Math.PI + 360) % 360;
            }

            if (Number.isFinite(speedVal)) {
                speeds.push(speedVal);
                units.push(detectSpeedUnit(speedHit?.key || ''));
            }
            if (Number.isFinite(dirDeg)) {
                dirs.push(((dirDeg % 360) + 360) % 360);
            }
        }

        if (speeds.length === 0) return null;
        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        const maxSpeed = Math.max(...speeds);
        const unit = units.find((u) => !!u) || '';

        let dirDegAvg = null;
        if (dirs.length > 0) {
            const sinSum = dirs.reduce((s, d) => s + Math.sin(d * Math.PI / 180), 0);
            const cosSum = dirs.reduce((s, d) => s + Math.cos(d * Math.PI / 180), 0);
            dirDegAvg = (Math.atan2(sinSum, cosSum) * 180 / Math.PI + 360) % 360;
        }

        return {
            sampleCount: speeds.length,
            avgSpeed,
            maxSpeed,
            unit,
            dirDeg: dirDegAvg,
            dirText: degToCompass(dirDegAvg),
        };
    }

    async function fetchTidePrediction() {
        try {
            const stationCode = getStation();
            const dateStr = getDateStr();
            let items = [];
            try {
                items = await apiCall('surveyTideLevel/GetSurveyTideLevelApiService', {
                    obsCode: stationCode,
                    reqDate: dateStr,
                    min: '10',
                    numOfRows: '300',
                    pageNo: '1'
                });
            } catch(e) {
                // ì‹¤ì¸¡ API ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (ë¯¸ë˜ ë‚ ì§œ ë“±)
            }

            let tideBedItems = [];
            try {
                tideBedItems = await apiCall('tidebed/GetTideBedPreApiService', {
                    obsCode: stationCode,
                    reqDate: dateStr,
                    numOfRows: '1500',
                    pageNo: '1'
                });
            } catch(e) {
                // tidebed ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ë³´ê°„ ì˜ˆì¸¡ ìœ ì§€
            }

            let tideTimeItems = [];
            try {
                tideTimeItems = await apiCall('tideFcstTime/GetTideFcstTimeApiService', {
                    obsCode: stationCode,
                    reqDate: dateStr,
                    min: '10',
                    numOfRows: '300',
                    pageNo: '1'
                });
            } catch(e) {
                // tideFcstTime ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
            }

            const hlData = window._hlData || [];
            let labels = [], predicted = [], actual = null;

            // ì˜ˆì¸¡ì¡°ìœ„: í•­ìƒ ê³ ì €ì¡° ë³´ê°„ìœ¼ë¡œ 05:00~18:00 ì „ì²´ ê³¡ì„  ìƒì„±
            if (hlData.length >= 2) {
                const interp = interpolateFromHiLo(hlData);
                labels = interp.labels;
                predicted = interp.predicted;
            }

            const tideBedMap = buildTimeSeriesMap(
                tideBedItems,
                ['predcDt', 'predcTm', 'predcTime', 'tm', 'dateTime', 'obsrvnDt'],
                ['predcTdlvVl', 'bscTdlvHgt', 'tdlvHgt', 'tdlvVl', 'tideLevel']
            );
            const tideTimeMap = buildTimeSeriesMap(
                tideTimeItems,
                ['predcDt', 'predcTm', 'predcTime', 'tm', 'dateTime'],
                ['predcTdlvVl', 'bscTdlvHgt', 'tdlvHgt', 'tdlvVl']
            );

            if (labels.length > 0) {
                // ìš°ì„ ìˆœìœ„: tidebed(1ë¶„ ì˜ˆì¸¡) > tideFcstTime(ì‹œê³„ì—´ ì˜ˆì¸¡) > ê³ ì €ì¡° ë³´ê°„
                predicted = mergePredictedWithSeriesMap(labels, predicted, tideTimeMap);
                predicted = mergePredictedWithSeriesMap(labels, predicted, tideBedMap);
            } else {
                const fromBed = buildLabelsAndPredictedFromSeriesMap(tideBedMap);
                const fromTime = buildLabelsAndPredictedFromSeriesMap(tideTimeMap);
                if (fromBed.labels.length > 0) {
                    labels = fromBed.labels;
                    predicted = fromBed.predicted;
                } else if (fromTime.labels.length > 0) {
                    labels = fromTime.labels;
                    predicted = fromTime.predicted;
                }
            }

            if (items && items.length > 0 && labels.length > 0) {
                // ì‹¤ì¸¡ì¡°ìœ„: API ì‹¤ì¸¡ê°’ì„ ë³´ê°„ ë¼ë²¨ì— ë§¤í•‘
                const actualMap = {};
                items.forEach(d => {
                    const t = normalizeClockTime(extractByKeysCaseInsensitive(d, ['obsrvnDt', 'obsrvnTm', 'obsrvnTime', 'tm', 'dateTime', 'predcDt', 'predcTm']));
                    if (!t) return;
                    actualMap[t] = toFiniteNumber(extractByKeysCaseInsensitive(d, ['tdlvHgt', 'obsrvnTdlvHgt', 'obsTdlvHgt', 'tideLevel', 'obsTideLevel']));
                });
                actual = labels.map(lbl => actualMap[lbl] != null ? actualMap[lbl] : null);
            } else if (items && items.length > 0 && labels.length === 0) {
                // ê³ ì €ì¡° ì—†ê³  ì‹¤ì¸¡ë§Œ ìˆëŠ” ê²½ìš° (fallback)
                const sortedRows = items
                    .map(d => ({
                        t: normalizeClockTime(extractByKeysCaseInsensitive(d, ['obsrvnDt', 'obsrvnTm', 'obsrvnTime', 'tm', 'dateTime', 'predcDt', 'predcTm'])),
                        p: toFiniteNumber(extractByKeysCaseInsensitive(d, ['bscTdlvHgt', 'predcTdlvVl', 'tdlvVl'])),
                        a: toFiniteNumber(extractByKeysCaseInsensitive(d, ['tdlvHgt', 'obsrvnTdlvHgt', 'obsTdlvHgt', 'tideLevel', 'obsTideLevel']))
                    }))
                    .filter(r => !!r.t)
                    .sort((a, b) => a.t.localeCompare(b.t));
                labels = sortedRows.map(r => r.t);
                predicted = sortedRows.map(r => r.p);
                actual = sortedRows.map(r => r.a);
            } else {
                actual = null;
            }

            if (!labels || labels.length === 0) {
                renderTideChart([], []); return;
            }

            // 05:00~18:00 ë²”ìœ„ë§Œ í•„í„°ë§
            const timeFilter = (lbl) => lbl >= '05:00' && lbl <= '18:00';
            const filterIndices = labels.map((l, i) => timeFilter(l) ? i : -1).filter(i => i >= 0);
            const fLabels = filterIndices.map(i => labels[i]);
            const fPredicted = filterIndices.map(i => predicted[i]);
            let fActual = actual ? filterIndices.map(i => actual[i]) : null;
            // fActual ë°°ì—´ ê¸¸ì´ë¥¼ fLabelsì™€ ë™ì¼í•˜ê²Œ ìœ ì§€ (Chart.js ë§¤í•‘ ë³´ì¥)

            const _fValid = fPredicted.filter(v => v != null);
            const _dataMin = _fValid.length > 0 ? Math.min(..._fValid) : 0;
            const _lowTimeLabelBase = _dataMin <= 70 ? 70 : _dataMin;
            const _lowTimeLabelAdjust = _dataMin <= 70 ? 21 : 24;
            let annotations = {};
            hlData.forEach((item, idx) => {
                const time = item.predcDt.substring(11, 16);
                const nearIdx = fLabels.findIndex(l => {
                    const [h1, m1] = l.split(':').map(Number);
                    const [h2, m2] = time.split(':').map(Number);
                    return Math.abs((h1 * 60 + m1) - (h2 * 60 + m2)) <= 5;
                });
                if (nearIdx < 0) return;
                const isHigh = parseInt(item.extrSe) % 2 === 1;

                annotations['hl_' + idx] = {
                    type: 'point', xValue: nearIdx, yValue: item.predcTdlvVl,
                    backgroundColor: isHigh ? 'rgba(255,107,107,0.8)' : 'rgba(78,205,196,0.8)',
                    radius: 7, borderColor: '#fff', borderWidth: 2,
                };
                annotations['hl_label_' + idx] = {
                    type: 'label', xValue: nearIdx,
                    yValue: item.predcTdlvVl,
                    yAdjust: isHigh ? 24 : -24,
                    content: `${isHigh ? 'ê³ ì¡°' : 'ì €ì¡°'} ${item.predcTdlvVl.toFixed(0)}cm`,
                    color: isHigh ? '#ff6b6b' : '#4ecdc4',
                    font: { size: 11, weight: 'bold' },
                    z: 10,
                };
                annotations['hl_time_' + idx] = {
                    type: 'label', xValue: nearIdx,
                    yValue: isHigh ? item.predcTdlvVl : _lowTimeLabelBase,
                    yAdjust: isHigh ? -16 : _lowTimeLabelAdjust,
                    content: time,
                    color: isHigh ? '#ff6b6b' : '#4ecdc4',
                    font: { size: 10, weight: '600' },
                    z: 10,
                };
            });

            // ì¼ì¶œ/ì¼ëª° ê·¸ë˜í”„ ë§ˆì»¤
            const sunTimes = getSunTimesForStation(getDateStr(), getStation());
            window._sunTimes = sunTimes;
            const isMobile = window.innerWidth <= 600;
            const chartSunEl = document.getElementById('chartSunInfo');
            if (isMobile && chartSunEl) {
                const parts = [];
                if (sunTimes.sunrise) parts.push('ì¼ì¶œ ' + sunTimes.sunrise);
                if (sunTimes.sunset) parts.push('ì¼ëª° ' + sunTimes.sunset);
                chartSunEl.textContent = parts.join(' | ');
                chartSunEl.style.display = parts.length ? '' : 'none';
            } else if (chartSunEl) {
                chartSunEl.style.display = 'none';
            }
            // ì¼ì¶œ í¬ì¸íŠ¸: í˜„ì¬ ìœ„ì¹˜ ë§ˆì»¤ì™€ ìœ ì‚¬í•˜ê²Œ í‘œì‹œ(ì˜¤ë Œì§€, ë” ì‘ì€ í¬ê¸°)
            if (sunTimes.sunrise) {
                const sunriseIdx = fLabels.findIndex(l => {
                    const [h1, m1] = l.split(':').map(Number);
                    const [h2, m2] = sunTimes.sunrise.split(':').map(Number);
                    return Math.abs((h1 * 60 + m1) - (h2 * 60 + m2)) <= 5;
                });
                if (sunriseIdx >= 0) {
                    const sunriseY = fPredicted[sunriseIdx] != null ? fPredicted[sunriseIdx] : 0;
                    annotations['sunrise_point'] = {
                        type: 'point', xValue: sunriseIdx, yValue: sunriseY,
                        backgroundColor: 'rgba(255,183,77,0.95)',
                        radius: 4, borderColor: '#fff', borderWidth: 1.5,
                        z: 11,
                    };
                }
            }

            // í™œì„±ë„ ë°ì´í„° ì €ì¥ (ì–´ì¢… ë²„íŠ¼ìš©)
            window._chartData = { labels: fLabels, predicted: fPredicted, actual: fActual, annotations };
            renderTideChart(fLabels, fPredicted, fActual, annotations);
        } catch(e) {
            console.error('ì¡°ìœ„ ê·¸ë˜í”„ ì˜¤ë¥˜:', e);
            renderTideChart([], []);
        }
    }

    // ==================== ì–´ì¢…ë³„ í™œì„±ë„ ê³„ì‚° ====================
    // ì¡°ìœ„ ë³€í™”ìœ¨(ê¸°ìš¸ê¸°)ë¡œ ì¡°ë¥˜ ê°•ë„ë¥¼ ì¶”ì •í•˜ê³ , ì–´ì¢…ë³„ íŒ¨í„´ì— ë§ì¶° í™œì„±ë„ ì‚°ì¶œ
    // ì¶œì²˜: ë‚šì‹œ ì»¤ë®¤ë‹ˆí‹° ì¢…í•© (ë°”ë‹¤íƒ€ì„, í”¼ì‹±íŠ¸ë¦½, ë‚šì‹œì¶˜ì¶” ë“±)
    //
    // ğŸ™ ì­ˆê¾¸ë¯¸: ì¤‘ê°„~ê°•í•œ ì¡°ë¥˜ ì‹œ í™œì„± â†‘ (ë“¤ë¬¼/ë‚ ë¬¼ ì¤‘ë°˜). ì •ì¡° ì‹œ í™œì„± â†“
    // ğŸ¦‘ ê°‘ì˜¤ì§•ì–´: ì¡°ë¥˜ íë¥¼ ë•Œ í™œì„± â†‘ (ì¤‘ë“¤ë¬¼/ì¤‘ì°ë¬¼). ì •ì¡° ì‹œ ì…ì§ˆ ëŠê¹€. ê°„ì¡° ì „í›„ ì›Œí‚¹ ì¢‹ìŒ
    // ğŸ™ ë¬¸ì–´: ì¡°ë¥˜ ì•½í•´ì§€ëŠ” ì •ì¡° ì „í›„ í™œì„± â†‘ (ì´ˆë“¤ë¬¼ í™©ê¸ˆì‹œê°„). ê°•í•œ ì¡°ë¥˜ ì‹œ í™œì„± â†“

    // â”€â”€ ì •ì¡°/ë¬¼ëŒì´ ì‹œê°„ ìƒìˆ˜ (10ë¶„ ê°„ê²© ê¸°ì¤€) â”€â”€
    const SLACK_HALF = 3;  // ì •ì¡°: ì¤‘ì‹¬ Â±3 = 6í¬ì¸íŠ¸ = 1ì‹œê°„
    const TURN_LEN = 6;   // ë¬¼ëŒì´: 6í¬ì¸íŠ¸ = 1ì‹œê°„

    // â”€â”€ ì–´ì¢…ë³„ pct íŒì • í†µí•© ìƒìˆ˜ â”€â”€
    // grade ìƒ‰ìƒ (í•œ ê³³ì—ì„œ ê´€ë¦¬)
    const GRADE_COLORS = {
        'ìµœìƒ': '#69f0ae', 'ì¢‹ìŒ': '#4fc3f7', 'ë³´í†µ': '#ffa726', 'ë‚®ìŒ': '#ff6b6b'
    };

    // ì–´ì¢…ë³„ íŒì • ê·œì¹™ (ì„ê³„ê°’ + ì„¤ëª… í†µí•©)
    const SPECIES_RULES = {
        jjukkumi: {
            emoji: 'ğŸ™', name: 'ì­ˆê¾¸ë¯¸',
            // ì„ ìƒ: ì¡°ê¸ˆ~ì¤‘ë¬¼ ì„ í˜¸, ì¤‘ê°„ ì¡°ë¥˜ ìµœì 
            rules: [
                { cond: (p, n) => n === 'ì¡°ê¸ˆ' || n === 'ë¬´ì‹œ', grade: 'ì¢‹ìŒ', desc: 'ì•½í•œ ì¡°ë¥˜, ë°”ë‹¥ íƒìƒ‰ ìš©ì´', mulddaeDesc: 'ì¡°ë¥˜ ì•½í•œ ë‚  â€” ë°”ë‹¥ íƒìƒ‰ìœ¼ë¡œ ì…ì§ˆ ê°€ëŠ¥, ì„ ìƒ ì í•©' },
                { cond: (p, n) => n === '1ë¬¼' || n === '2ë¬¼',   grade: 'ìµœìƒ', desc: 'ì„ ìƒ ìµœì  â€” ì ì • ì¡°ë¥˜', mulddaeDesc: (n) => `${n} â€” ì´ˆë“¤ë¬¼, ì„ ìƒ ìµœì  ì¡°ë¥˜` },
                { cond: (p, n) => p >= 40 && p <= 70,           grade: 'ìµœìƒ', desc: 'ì¤‘ê°„ ì¡°ë¥˜, í™œì„± ìµœê³ ', mulddaeDesc: (n) => `${n} â€” ì¤‘ê°„ ì¡°ë¥˜ë¡œ ì„ ìƒ ì­ˆê¾¸ë¯¸ ìµœì !` },
                { cond: (p, n) => p >= 80,                      grade: 'ë³´í†µ', desc: 'ì¡°ë¥˜ ê°•í•´ ì±„ë¹„ ì»¨íŠ¸ë¡¤ ì–´ë ¤ì›€', mulddaeDesc: (n) => `${n} â€” ì¡°ë¥˜ ê°•í•´ ì±„ë¹„ ì»¨íŠ¸ë¡¤ ì£¼ì˜ (ë¬´ê±°ìš´ ë´‰ëŒ í•„ìš”)` },
                { cond: (p, n) => p >= 30,                      grade: 'ì¢‹ìŒ', desc: 'ì ë‹¹í•œ ì¡°ë¥˜', mulddaeDesc: (n) => `${n} â€” ì ë‹¹í•œ ì¡°ë¥˜, ì¢‹ì€ ì¡°ê±´` },
                { cond: () => true,                             grade: 'ì¢‹ìŒ', desc: 'ì •ì¡°ì—ë„ ë°”ë‹¥ ì…ì§ˆ ê°€ëŠ¥', mulddaeDesc: (n) => `${n} â€” ì ë‹¹í•œ ì¡°ë¥˜, ì¢‹ì€ ì¡°ê±´` }
            ]
        },
        gapoh: {
            emoji: 'ğŸ¦‘', name: 'ê°‘ì˜¤ì§•ì–´',
            // ì„ ìƒ: 3~8ë¬¼ ì ì • ì¡°ë¥˜ ìµœì , ì •ì¡° ì‹œ í™œì„± ë‚®ìŒ
            rules: [
                { cond: (p, n) => n === 'ì¡°ê¸ˆ' || n === 'ë¬´ì‹œ', grade: 'ë‚®ìŒ', desc: 'ì¡°ë¥˜ ë¶€ì¡±, í™œì„± ë‚®ìŒ', mulddaeDesc: 'ì¡°ë¥˜ ë¶€ì¡±í•œ ë‚  â€” í™œì„± ë‚®ìŒ, ì¶œì¡° ë¹„ì¶”ì²œ' },
                { cond: (p, n) => p >= 55 && p <= 85,           grade: 'ìµœìƒ', desc: '3~8ë¬¼ ì ì • ì¡°ë¥˜, ìµœì ', mulddaeDesc: (n) => `${n} â€” 3~8ë¬¼ ì ì • ì¡°ë¥˜, ê°‘ì˜¤ì§•ì–´ ìµœì !` },
                { cond: (p, n) => p >= 85,                      grade: 'ì¢‹ìŒ', desc: 'ì¡°ë¥˜ ê°•í•˜ì§€ë§Œ í™œì„± ìˆìŒ', mulddaeDesc: (n) => `${n} â€” ê°•í•œ ì¡°ë¥˜, ì¥ì• ë¬¼ ë’¤ ë§¤ë³µ í¬ì¸íŠ¸ ê³µëµ` },
                { cond: (p, n) => p >= 35,                      grade: 'ë³´í†µ', desc: 'ì•½í•œ ì¡°ë¥˜, ì •ì¡° ì‹œê°„ ì£¼ì˜', mulddaeDesc: (n) => `${n} â€” ì•½í•œ ì¡°ë¥˜, ë¬¼ëŒì´ íƒ€ì„ ì§‘ì¤‘` },
                { cond: () => true,                             grade: 'ë‚®ìŒ', desc: 'ì¡°ë¥˜ ë¶€ì¡±', mulddaeDesc: 'ì¡°ë¥˜ ë¶€ì¡±' }
            ]
        },
        muneo: {
            emoji: 'ğŸ™', name: 'ë¬¸ì–´',
            // ì •ì¡° ì „í›„ í™œì„±â†‘, ì´ˆë“¤ë¬¼ í™©ê¸ˆì‹œê°„, ê°•í•œ ì¡°ë¥˜ ì‹œ ì€ì‹ 
            rules: [
                { cond: (p, n) => n === 'ì¡°ê¸ˆ' || n === 'ë¬´ì‹œ', grade: 'ìµœìƒ', desc: 'ì •ì¡° ë§ì•„ ë¨¹ì´í™œë™ í™œë°œ', mulddaeDesc: 'ì •ì¡° ë§ì€ ë‚  â€” ë¨¹ì´í™œë™ í™œë°œ, ë¬¸ì–´ ìµœì !' },
                { cond: (p, n) => n === '1ë¬¼' || n === '2ë¬¼',   grade: 'ìµœìƒ', desc: 'ì´ˆë“¤ë¬¼ í™©ê¸ˆì‹œê°„ ë§ìŒ', mulddaeDesc: (n) => `${n} â€” ì´ˆë“¤ë¬¼ í™©ê¸ˆì‹œê°„ ë§ìŒ, ìµœì !` },
                { cond: (p, n) => p >= 80,                      grade: 'ë‚®ìŒ', desc: 'ê°•í•œ ì¡°ë¥˜, ì€ì‹  ê²½í–¥', mulddaeDesc: (n) => `${n} â€” ê°•í•œ ì¡°ë¥˜, ì •ì¡° ì‹œê°„ëŒ€ë§Œ ë…¸ë ¤ì•¼` },
                { cond: (p, n) => p >= 55,                      grade: 'ë³´í†µ', desc: 'ì •ì¡° ì‹œê°„ëŒ€ ë…¸ë ¤ì•¼ í•¨', mulddaeDesc: (n) => `${n} â€” ì •ì¡° ì „í›„ ì‹œê°„ëŒ€ ì§‘ì¤‘ ê³µëµ` },
                { cond: () => true,                             grade: 'ì¢‹ìŒ', desc: 'ì•½í•œ ì¡°ë¥˜, í™œë™ â†‘', mulddaeDesc: (n) => `${n} â€” ì•½í•œ ì¡°ë¥˜, í™œë™ â†‘` }
            ]
        }
    };

    // í†µí•© íŒì • í•¨ìˆ˜: ì–´ì¢… í‚¤ + pct + ë¬¼ë•Œì´ë¦„ â†’ { grade, color, desc, mulddaeDesc }
    function getSpeciesSuitability(speciesKey, pct, num) {
        const species = SPECIES_RULES[speciesKey];
        if (!species) return null;
        for (const rule of species.rules) {
            if (rule.cond(pct, num)) {
                const mulddaeText = typeof rule.mulddaeDesc === 'function' ? rule.mulddaeDesc(num) : rule.mulddaeDesc;
                return { grade: rule.grade, color: GRADE_COLORS[rule.grade], desc: rule.desc, mulddaeDesc: mulddaeText };
            }
        }
        return null;
    }

    // ë¬¼ë•Œ(ëª‡ë¬¼)ë³„ ì–´ì¢… ì í•©ë„ â€” ë¬¼ë•Œ ì¹´ë“œì— í‘œì‹œ
    function getSpeciesByMulddae(mulddaeNum, mulddaePct) {
        return Object.entries(SPECIES_RULES).map(([key, sp]) => {
            const suit = getSpeciesSuitability(key, mulddaePct, mulddaeNum);
            return { emoji: sp.emoji, name: sp.name, ...suit };
        });
    }

    // ì„ ìƒë‚šì‹œ ê¸°ì¤€ ì–´ì¢…ë³„ ì„¤ì •
    // ë¬¼ëŒì´(Turn of Tide) = ì •ì¡°â†’ìœ ì† ì „í™˜ ì‹œì‘ì  = ìµœê³  í”¼ë”©íƒ€ì„
    const SPECIES_CONFIG = {
        jjukkumi: {
            name: 'ì­ˆê¾¸ë¯¸', emoji: 'ğŸ™', color: '#e040fb',
            legend: 'ğŸ™ ì­ˆê¾¸ë¯¸ â€” ì¤‘ê°„ ì¡°ë¥˜ ì‹œ í™œì„± ìµœê³  | ì •ì¡°ì—ë„ ë°”ë‹¥ íƒìƒ‰ìœ¼ë¡œ ì…ì§ˆ ìˆìŒ | ì„ ìƒ ì¡°ê¸ˆ~ì¤‘ë¬¼ ì í•©'
        },
        gapoh: {
            name: 'ê°‘ì˜¤ì§•ì–´', emoji: 'ğŸ¦‘', color: '#ff9100',
            legend: 'ğŸ¦‘ ê°‘ì˜¤ì§•ì–´ â€” ì´ˆë“¤ë¬¼ í”¼ë”©íƒ€ì„ | ë“¤ë¬¼ > ë‚ ë¬¼ | ì •ì¡° ì‹œ ì…ì§ˆê°ì§€ ì–´ë ¤ì›€'
        },
        muneo: {
            name: 'ë¬¸ì–´', emoji: 'ğŸ™', color: '#69f0ae',
            legend: 'ğŸ™ ë¬¸ì–´ â€” ì •ì¡° ì „í›„ ë¨¹ì´í™œë™ â†‘ | ì´ˆë“¤ë¬¼ í™©ê¸ˆì‹œê°„ | ê°•í•œ ì¡°ë¥˜ ì‹œ ì€ì‹ '
        }
    };

    let activeSpecies = 'none';

    function calcTideRates(predicted) {
        const n = predicted.length;
        if (n < 2) return predicted.map(() => 0);

        // 1ë‹¨ê³„: ë„“ì€ ìœˆë„ìš°(ì „í›„ 6í¬ì¸íŠ¸=1ì‹œê°„)ë¡œ ë³€í™”ìœ¨ ê³„ì‚°
        const W = 6;
        const rawRates = [];
        for (let i = 0; i < n; i++) {
            const lo = Math.max(0, i - W);
            const hi = Math.min(n - 1, i + W);
            if (predicted[lo] != null && predicted[hi] != null && hi > lo) {
                rawRates.push((predicted[hi] - predicted[lo]) / (hi - lo));
            } else {
                rawRates.push(0);
            }
        }

        // 2ë‹¨ê³„: ì´ë™í‰ê·  ìŠ¤ë¬´ë”© (ìœˆë„ìš° 9í¬ì¸íŠ¸)
        const SW = 9;
        const smoothed = [];
        for (let i = 0; i < n; i++) {
            let sum = 0, cnt = 0;
            for (let j = Math.max(0, i - SW); j <= Math.min(n - 1, i + SW); j++) {
                sum += rawRates[j]; cnt++;
            }
            smoothed.push(cnt > 0 ? sum / cnt : 0);
        }

        // 3ë‹¨ê³„: ì •ê·œí™” (ìµœëŒ€ ì ˆëŒ€ê°’ ê¸°ì¤€ 0~1)
        const maxAbs = Math.max(...smoothed.map(Math.abs), 0.001);
        return smoothed.map(v => v / maxAbs);
    }

    function toggleSpecies(species) {
        activeSpecies = (activeSpecies === species) ? 'none' : species;

        // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
        document.querySelectorAll('.species-btn').forEach(btn => {
            const s = btn.dataset.species;
            if (s === activeSpecies) {
                const cfg = SPECIES_CONFIG[s];
                btn.style.background = cfg ? cfg.color + '22' : 'rgba(255,255,255,0.1)';
                btn.style.borderColor = cfg ? cfg.color : 'var(--muted)';
                btn.style.color = cfg ? cfg.color : 'var(--text)';
            } else {
                btn.style.background = 'transparent';
                btn.style.borderColor = 'var(--border)';
                btn.style.color = 'var(--muted)';
            }
        });

        // speciesLegend â†’ ì¢‹ì€/ì•ˆì¢‹ì€ ì‹œê°„ëŒ€ í‘œì‹œ (ì°¨íŠ¸ ìœ„)
        updateSpeciesTimeRanges();

        // ë¬¼ë•Œ ì¹´ë“œì— ì„ íƒëœ ì–´ì¢… ì„¤ëª… ì—…ë°ì´íŠ¸
        updateMulddaeSpeciesInfo();

        // ì°¨íŠ¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        if (window._chartData && window._chartData.labels && window._chartData.labels.length > 0) {
            const { labels, predicted, actual, annotations } = window._chartData;
            renderTideChart(labels, predicted, actual, annotations);
        }
    }

    // ì°¨íŠ¸ ìœ„ speciesLegendì— ë¬¼ëŒì´ ì‹œê°„ ë° ì–´ì¢… ë²”ë¡€ í‘œì‹œ
    function updateSpeciesTimeRanges() {
        const legendEl = document.getElementById('speciesLegend');
        if (activeSpecies === 'none' || !SPECIES_CONFIG[activeSpecies] || !window._chartData) {
            legendEl.style.display = 'none';
            return;
        }
        const cfg = SPECIES_CONFIG[activeSpecies];
        const { labels, predicted } = window._chartData;
        if (!predicted || predicted.length === 0) { legendEl.style.display = 'none'; return; }

        // ê¸°ì¡´ ê³ ì¡°/ì €ì¡° annotation ìœ„ì¹˜ ê¸°ë°˜ ì •ì¡°/ë¬¼ëŒì´ ì‹œê° ê°ì§€
        const rates = calcTideRates(predicted);
        const slackZones = [];
        const turnTimes = [];
        const anns = window._chartData.annotations || {};
        const hlPoints = [];
        Object.keys(anns).forEach(key => {
            if (key.match(/^hl_\d+$/) && anns[key].xValue != null) {
                hlPoints.push(anns[key].xValue);
            }
        });
        hlPoints.sort((a, b) => a - b);
        hlPoints.forEach(center => {
            const redStart = Math.max(0, center - SLACK_HALF);
            const redEnd = Math.min(labels.length - 1, center + SLACK_HALF);
            const turnEnd = Math.min(labels.length - 1, redEnd + TURN_LEN);
            slackZones.push({ start: labels[redStart] || '', end: labels[redEnd] || '' });
            const turnRate = rates[redEnd] != null ? rates[redEnd] : 0;
            turnTimes.push({ time: labels[redEnd] || '', type: turnRate > 0 ? 'ë“¤ë¬¼' : 'ë‚ ë¬¼' });
        });

        legendEl.style.display = '';
        legendEl.innerHTML = `
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
                <span style="color:${cfg.color};font-weight:700;font-size:0.95em;">${cfg.legend}</span>
            </div>
            ${slackZones.length > 0 ? `
            <div style="display:flex;align-items:center;gap:6px;margin-top:6px;">
                <span style="font-size:0.82em;color:#ff5252;font-weight:700;min-width:72px;">â¸ ì •ì¡° êµ¬ê°„</span>
                <span style="font-size:0.78em;color:var(--muted);">|</span>
                ${slackZones.map(z => `
                    <div style="flex:1;display:flex;align-items:center;justify-content:center;padding:3px 10px;background:rgba(255,82,82,0.08);border-radius:6px;border-left:3px solid #ff5252;">
                        <span style="font-size:0.85em;color:var(--text);font-weight:600;">${z.start}~${z.end}</span>
                    </div>
                `).join('')}
            </div>` : ''}
            ${turnTimes.length > 0 ? `
            <div style="display:flex;align-items:center;gap:6px;margin-top:4px;">
                <span style="font-size:0.82em;color:#4caf50;font-weight:700;min-width:72px;">ğŸŸ¢ ë¬¼ëŒì´</span>
                <span style="font-size:0.78em;color:var(--muted);">|</span>
                ${turnTimes.map(t => `
                    <div style="flex:1;display:flex;align-items:center;justify-content:center;gap:5px;padding:3px 10px;background:rgba(76,175,80,0.1);border-radius:6px;border-left:3px solid #4caf50;">
                        <span style="font-size:0.85em;color:var(--text);font-weight:600;">${t.time}</span>
                        <span style="font-size:0.72em;color:${t.type === 'ë“¤ë¬¼' ? '#4fc3f7' : '#ff8a65'};font-weight:600;">â†’${t.type}</span>
                    </div>
                `).join('')}
            </div>` : ''}`;
    }

    // ë¬¼ë•Œ ì¹´ë“œì— ì„ íƒëœ ì–´ì¢…ì˜ ë¬¼ë•Œ ê¸°ë°˜ ì„¤ëª… í‘œì‹œ
    function updateMulddaeSpeciesInfo() {
        const infoEl = document.getElementById('mulddaeSpeciesInfo');
        if (!infoEl) return;
        if (activeSpecies === 'none' || !SPECIES_CONFIG[activeSpecies]) {
            infoEl.style.display = 'none';
            return;
        }
        const cfg = SPECIES_CONFIG[activeSpecies];
        const mulddaeEl = document.getElementById('mulddaeInfo');
        if (!mulddaeEl) return;

        // í˜„ì¬ ë¬¼ë•Œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        const mulddae = getMulddaeInfo(getDateStr());
        if (Number.isFinite(window._lastMulddaePct)) {
            mulddae.pct = window._lastMulddaePct;
        }
        // í†µí•© íŒì • í•¨ìˆ˜ ì‚¬ìš© â€” ì„ê³„ê°’ì€ SPECIES_RULESì—ì„œ í•œ ê³³ ê´€ë¦¬
        const speciesTips = {
            jjukkumi: {
                slackTip: 'â¸ï¸ ì •ì¡°: ì§ê²° ì±„ë¹„ + ìºìŠ¤íŒ… ë“œë˜ê¹…, ë°”ë‹¥ ê¸ì–´ ìœ ì¸',
                turnTip: 'ğŸŸ¢ ë¬¼ëŒì´: ê°€ì§€ì¤„ 20~30cm ì „í™˜, ë¦¬í”„íŠ¸&í´ ì•¡ì…˜',
                rigTip: 'ğŸ£ ì •ì¡°â†’ì§§ì€ ê°€ì§€ì¤„(10cm) | ìœ ì†â†’ê¸´ ê°€ì§€ì¤„(20~40cm)'
            },
            gapoh: {
                slackTip: 'â¸ï¸ ì •ì¡°: ì„­ì´í™œë™ ìœ ì§€ë˜ë‚˜ ì…ì§ˆê°ì§€ ê·¹ë‚œ â€” ì‰ì´í‚¹ í›„ 5~10ì´ˆ ìŠ¤í…Œì´',
                turnTip: 'ğŸŸ¢ ë¬¼ëŒì´ 15~30ë¶„ì´ ìŠ¹ë¶€! í­ë°œì  í”¼ë”©, ë¹ ë¥¸ í…œí¬ ê³µëµ',
                rigTip: 'ğŸ£ ì •ì¡°â†’ì§ê²° ì±„ë¹„+ìˆ˜í‰ ì—ê¸° | ìœ ì†â†’ì‹œì¸ì„± ë†’ì€ ë ˆì´ì € ì—ê¸°'
            },
            muneo: {
                slackTip: 'â¸ï¸ ì •ì¡°: ë¨¹ì´í™œë™ í”¼í¬! ë°”ìœ„í‹ˆ/ì€ì‹ ì²˜ ì£¼ë³€ ê³µëµ',
                turnTip: 'ğŸ”¥ ì´ˆë“¤ë¬¼(ê°„ì¡°â†’ë§Œì¡° ì „í™˜): í™©ê¸ˆì‹œê°„ â€” ë¨¹ì´ ë– ì˜¬ë¼ í™œë°œ',
                rigTip: 'ğŸ£ ë¬´ê±°ìš´ ë´‰ëŒë¡œ ë°”ë‹¥ ë°€ì°©, ì €ì† ë“œë˜ê¹…'
            }
        };

        const tips = speciesTips[activeSpecies];
        if (!tips) { infoEl.style.display = 'none'; return; }
        const suit = getSpeciesSuitability(activeSpecies, mulddae.pct, mulddae.num);

        infoEl.style.display = '';
        infoEl.innerHTML = `
            <div style="padding:10px 12px;background:${cfg.color}08;border:1px solid ${cfg.color}25;border-radius:10px;">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:1.3em;">${cfg.emoji}</span>
                    <span style="font-weight:700;color:${cfg.color};font-size:0.92em;">${cfg.name} Â· ì˜¤ëŠ˜ ${mulddae.num} (${mulddae.name} ${mulddae.pct}%)</span>
                </div>
                <div style="font-size:0.84em;color:var(--text);margin-bottom:8px;font-weight:500;">${suit.mulddaeDesc}</div>
                <div style="display:flex;flex-direction:column;gap:4px;">
                    <div style="font-size:0.78em;color:var(--muted);padding:3px 0;border-top:1px solid ${cfg.color}15;">${tips.slackTip}</div>
                    <div style="font-size:0.78em;color:#ffa726;">${tips.turnTip}</div>
                    <div style="font-size:0.78em;color:var(--muted);">${tips.rigTip}</div>
                </div>
            </div>`;
    }

    function renderTideChart(labels, predicted, actual, baseAnnotations = {}) {
        window._zoneData = []; // ë§¤ ë Œë”ë§ë§ˆë‹¤ ì´ˆê¸°í™”
        const annotations = { ...baseAnnotations };
        const canvasEl = document.getElementById('tideChart');
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        if (tideChart) tideChart.destroy();
        // ê°‘ì˜¤ì§•ì–´ê°€ ì•„ë‹ˆë©´ ëª¨ë°”ì¼ ì •ì¡°/ë¬¼ëŒì´ í…ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸°
        const _slackEl = document.getElementById('chartSlackInfo');
        if (_slackEl && activeSpecies !== 'gapoh') { _slackEl.style.display = 'none'; _slackEl.innerHTML = ''; }
        if (labels.length === 0) { tideChart = null; return; }

        const grad1 = ctx.createLinearGradient(0, 0, 0, 320);
        grad1.addColorStop(0, 'rgba(79,195,247,0.3)');
        grad1.addColorStop(1, 'rgba(79,195,247,0.02)');

        const datasets = [{
            label: 'ì˜ˆì¸¡ ì¡°ìœ„ (cm)',
            data: predicted,
            borderColor: '#4fc3f7',
            backgroundColor: grad1,
            borderWidth: 2, fill: true, tension: 0.4, cubicInterpolationMode: 'monotone', pointRadius: 0, pointHoverRadius: 0,
            order: 0,
        }];

        const normalizedActual = Array.isArray(actual)
            ? actual.map((v) => toFiniteNumber(v))
            : null;
        const hasActual = Array.isArray(normalizedActual)
            && normalizedActual.some((v) => v != null);
        const actualLineSegments = hasActual
            ? normalizedActual.reduce((cnt, v, idx, arr) => {
                if (idx === 0) return cnt;
                return (arr[idx - 1] != null && v != null) ? cnt + 1 : cnt;
            }, 0)
            : 0;
        const actualPointRadius = actualLineSegments > 0 ? 0 : 2.5;
        const actualPointHoverRadius = 0;

        if (hasActual) {
            datasets.push({
                label: 'ì‹¤ì¸¡ ì¡°ìœ„ (cm)',
                data: normalizedActual,
                borderColor: '#ffa726',
                borderWidth: 1.5, borderDash: [4, 4],
                fill: false, tension: 0.4, cubicInterpolationMode: 'monotone', pointRadius: actualPointRadius, pointHoverRadius: actualPointHoverRadius,
                order: 1, spanGaps: false,
            });
        }

        const _pValid = predicted.filter(v => v != null);
        const _aValid = hasActual ? normalizedActual.filter(v => v != null) : [];
        const _annYValues = Object.values(annotations)
            .map(a => (a && typeof a.yValue === 'number') ? a.yValue : null)
            .filter(v => v != null);
        const _yAll = _pValid.concat(_aValid, _annYValues);

        const yScale = {
            ticks: { stepSize: 100, color: '#7a8ba3', font: { size: 11 }, callback: v => v + ' cm' },
            grid: { color: 'rgba(255,255,255,0.06)' }
        };
        if (_yAll.length > 0) {
            const _yMinAuto = Math.min(..._yAll);
            const _yMaxAuto = Math.max(..._yAll);
            yScale.min = Math.min(0, Math.floor(_yMinAuto / 100) * 100);
            yScale.max = Math.max(100, Math.ceil(_yMaxAuto / 100) * 100);
        } else {
            yScale.min = 0;
            yScale.max = 100;
        }

        const scales = {
            x: { ticks: { color: '#7a8ba3', maxTicksLimit: 24, font: { size: 10 }, callback: function(val, idx) { const lbl = this.getLabelForValue(val); return lbl && lbl.endsWith(':00') ? lbl : null; } }, grid: { color: 'rgba(255,255,255,0.04)' } },
            y: yScale
        };
        if (activeSpecies === 'gapoh' && _pValid.length > 0) {
            const yMax = Math.max(..._pValid);
            const yMin = Math.min(..._pValid);
            const yCenter = (yMax + yMin) / 2;
            // ê¸°ì¡´ ê³ ì¡°/ì €ì¡° annotation(hl_) ìœ„ì¹˜ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            const hlPoints = [];
            Object.keys(annotations).forEach(key => {
                if (key.match(/^hl_\d+$/) && annotations[key].xValue != null) {
                    hlPoints.push(annotations[key].xValue);
                }
            });
            hlPoints.sort((a, b) => a - b);

            // ê° ê³ ì¡°/ì €ì¡° ì¤‘ì‹¬ìœ¼ë¡œ ì •ì¡°(1h) + ë¬¼ëŒì´(1h) ë°°ì¹˜
            const rates = calcTideRates(predicted);
            const isMob = window.innerWidth <= 600;
            const mobSlackTexts = [];
            const mobTurnTexts = [];
            hlPoints.forEach((center, zc) => {
                const redStart = Math.max(0, center - SLACK_HALF);
                const redEnd = Math.min(labels.length - 1, center + SLACK_HALF);
                const turnStart = redEnd;
                const turnEnd = Math.min(labels.length - 1, redEnd + TURN_LEN);

                // zone ë°ì´í„° ì €ì¥ (ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸ì—ì„œ ê·¸ë˜í”„ ì•ˆìª½ë§Œ ì±„ì›€)
                window._zoneData.push(
                    { start: redStart, end: redEnd, color: 'rgba(255,105,97,0.35)', border: null },
                    { start: turnStart, end: turnEnd, color: 'rgba(100,255,218,0.35)', border: null }
                );
                if (isMob) {
                    mobSlackTexts.push((labels[redStart] || '') + '~' + (labels[redEnd] || ''));
                    const turnRate = rates[redEnd] != null ? rates[redEnd] : 0;
                    mobTurnTexts.push((labels[redEnd] || '') + 'â†’' + (turnRate > 0 ? 'ë“¤ë¬¼' : 'ë‚ ë¬¼'));
                } else {
                    annotations['slack_label_' + zc] = {
                        type: 'label', xValue: (redStart + redEnd) / 2, yValue: yCenter,
                        content: ['â¸ ì •ì¡°', labels[redStart] || '', '~', labels[redEnd] || ''], color: '#ff6961',
                        font: { size: 10, weight: 'bold' },
                        backgroundColor: 'rgba(17,29,53,0.85)',
                        padding: { top: 3, bottom: 3, left: 6, right: 6 }, borderRadius: 4,
                    };
                    annotations['turn_label_' + zc] = {
                        type: 'label', xValue: (turnStart + turnEnd) / 2, yValue: yCenter,
                        content: ['ğŸŸ¢ ë¬¼ëŒì´', labels[turnStart] || '', '~', labels[turnEnd] || ''], color: '#64ffda',
                        font: { size: 10, weight: 'bold' },
                        backgroundColor: 'rgba(17,29,53,0.85)',
                        padding: { top: 3, bottom: 3, left: 6, right: 6 }, borderRadius: 4,
                    };
                }
            });
            // ëª¨ë°”ì¼: ê·¸ë˜í”„ ìœ„ì— ì •ì¡°/ë¬¼ëŒì´ ì‹œê°„ í‘œì‹œ
            const slackInfoEl = document.getElementById('chartSlackInfo');
            if (slackInfoEl) {
                if (isMob && mobSlackTexts.length > 0) {
                    slackInfoEl.style.display = 'flex';
                    slackInfoEl.innerHTML =
                        '<span style="padding:1px 5px;background:rgba(255,105,97,0.12);border:1px solid rgba(255,105,97,0.3);border-radius:3px;"><span style="color:#ff6961;font-weight:700;">â¸ ì •ì¡°</span> ' + mobSlackTexts.map(escapeHTML).join(' Â· ') + '</span>' +
                        '<span style="padding:1px 5px;background:rgba(100,255,218,0.10);border:1px solid rgba(100,255,218,0.25);border-radius:3px;"><span style="color:#64ffda;font-weight:700;">ğŸŸ¢ ë¬¼ëŒì´</span> ' + mobTurnTexts.map(escapeHTML).join(' Â· ') + '</span>';
                } else {
                    slackInfoEl.style.display = 'none';
                    slackInfoEl.innerHTML = '';
                }
            }
        }

        // í˜„ì¬ ì‹œê°„ ë§ˆì»¤ (ì˜¤ëŠ˜ ë‚ ì§œ + 05:00~18:00 ë²”ìœ„ ë‚´)
        const _today = new Date();
        const _selDate = document.getElementById('dateInput').value;
        const _todayStr = _today.getFullYear() + '-' + String(_today.getMonth()+1).padStart(2,'0') + '-' + String(_today.getDate()).padStart(2,'0');
        if (_selDate === _todayStr && labels.length > 0) {
            const nowH = _today.getHours(), nowM = _today.getMinutes();
            const nowTotal = nowH * 60 + nowM;
            // 10ë¶„ ë‹¨ìœ„ë¡œ ìŠ¤ëƒ…
            const snapped = Math.round(nowTotal / 10) * 10;
            const snapHH = String(Math.floor(snapped / 60)).padStart(2, '0');
            const snapMM = String(snapped % 60).padStart(2, '0');
            const nowLabel = snapHH + ':' + snapMM;
            const nowIdx = labels.indexOf(nowLabel);
            if (nowIdx >= 0) {
                const nowYActual = (hasActual && normalizedActual[nowIdx] != null) ? normalizedActual[nowIdx] : null;
                const nowY = nowYActual != null ? nowYActual : (predicted[nowIdx] != null ? predicted[nowIdx] : 0);
                annotations['now_point'] = {
                    type: 'point', xValue: nowIdx, yValue: nowY,
                    backgroundColor: 'rgba(255,235,59,0.9)',
                    radius: 5, borderColor: '#fff', borderWidth: 1.5,
                };
                const _yMin = _pValid.length > 0 ? Math.min(..._pValid) : 0;
                annotations['now_label'] = {
                    type: 'label', xValue: nowIdx, yValue: _yMin,
                    xAdjust: 0, yAdjust: 24,
                    content: nowLabel,
                    color: '#ffeb3b',
                    font: { size: 10, weight: 'bold' },
                };
                // ìˆ˜ì§ ì ì„  (í¬ì¸íŠ¸ê¹Œì§€ë§Œ)
                annotations['now_line'] = {
                    type: 'line', xMin: nowIdx, xMax: nowIdx,
                    yMax: nowY,
                    borderColor: 'rgba(255,235,59,0.4)',
                    borderWidth: 1, borderDash: [4, 4],
                };
                // ìˆ˜í‰ ì ì„ : í˜„ì¬ìœ„ì¹˜ â†’ ì¢Œì¸¡ Yì¶•ê¹Œì§€
                annotations['now_hline'] = {
                    type: 'line',
                    xMin: 0, xMax: nowIdx,
                    yMin: nowY, yMax: nowY,
                    borderColor: 'rgba(255,167,38,0.35)',
                    borderWidth: 1.5, borderDash: [5, 4],
                };
                // ê¸°ì¤€ê°’ ë¼ë²¨ (ì¢Œì¸¡ Yì¶• ë)
                annotations['now_hline_val'] = {
                    type: 'label',
                    xValue: 0, yValue: nowY,
                    xAdjust: -5,
                    content: '(' + nowY.toFixed(0) + ')',
                    color: '#ffa726',
                    font: { size: 8, weight: 'bold' },
                    backgroundColor: 'rgba(17,29,53,0.85)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 },
                    borderRadius: 3,
                    position: { x: 'start' },
                };
            }
        }

        // ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸: ì •ì¡°/ë¬¼ëŒì´ êµ¬ê°„ì„ ê·¸ë˜í”„ ê³¡ì„  ì•ˆìª½ë§Œ ì±„ì›€
        const zoneFillPlugin = {
            id: 'zoneFill',
            beforeDatasetsDraw(chart) {
                if (!window._zoneData || window._zoneData.length === 0) return;
                const { ctx: c, chartArea, scales: { x: xScale, y: yScale } } = chart;
                const meta = chart.getDatasetMeta(0); // predicted ë°ì´í„°ì…‹
                if (!meta || !meta.data || meta.data.length === 0) return;
                c.save();
                // chartArea ë°– í´ë¦½
                c.beginPath();
                c.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                c.clip();
                window._zoneData.forEach(zone => {
                    const startIdx = Math.max(0, Math.floor(zone.start));
                    const endIdx = Math.min(meta.data.length - 1, Math.ceil(zone.end));
                    if (startIdx >= endIdx) return;
                    // fill: ê·¸ë˜í”„ ì„  ì•„ë˜ â†’ xì¶•ê¹Œì§€
                    c.beginPath();
                    const firstPt = meta.data[startIdx];
                    c.moveTo(firstPt.x, chartArea.bottom);
                    for (let i = startIdx; i <= endIdx; i++) {
                        const pt = meta.data[i];
                        if (pt) c.lineTo(pt.x, pt.y);
                    }
                    const lastPt = meta.data[endIdx];
                    c.lineTo(lastPt.x, chartArea.bottom);
                    c.closePath();
                    c.fillStyle = zone.color;
                    c.fill();
                });
                c.restore();
            }
        };

        tideChart = new Chart(ctx, {
            type: 'line',
            data: { labels, datasets },
            plugins: [zoneFillPlugin],
            options: {
                responsive: true, maintainAspectRatio: false,
                layout: { padding: { top: 24, right: 15, bottom: 20 } },
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false },
                    annotation: { clip: false, drawTime: 'afterDraw', annotations }
                },
                scales
            }
        });

        // ì»¤ìŠ¤í…€ ë²”ë¡€ ì—…ë°ì´íŠ¸
        const tideLegendEl = document.getElementById('tideLegend');
        if (tideLegendEl) {
            const hasNow = !!annotations['now_point'];
            const sunriseTime = (window._sunTimes && window._sunTimes.sunrise) ? window._sunTimes.sunrise : null;
            const sunsetTime = (window._sunTimes && window._sunTimes.sunset) ? window._sunTimes.sunset : null;
            const hasSunInfo = !!(sunriseTime || sunsetTime);
            let html = '<span style="display:flex;align-items:center;gap:4px;"><span style="width:18px;height:3px;background:#4fc3f7;border-radius:2px;flex-shrink:0;"></span><span style="color:#7a8ba3;">ì˜ˆì¸¡ ì¡°ìœ„</span></span>';
            if (hasActual) {
                html += '<span style="display:flex;align-items:center;gap:4px;"><span style="width:18px;height:0;border-top:2px dashed #ffa726;flex-shrink:0;"></span><span style="color:#7a8ba3;">ì‹¤ì¸¡ ì¡°ìœ„</span></span>';
            }
            if (hasNow) {
                html += '<span style="display:flex;align-items:center;gap:4px;"><span style="width:8px;height:8px;background:#ffeb3b;border-radius:50%;border:1px solid #fff;flex-shrink:0;"></span><span style="color:#ffeb3b;">í˜„ì¬ ìœ„ì¹˜</span></span>';
            }
            if (hasSunInfo) {
                const sunLabel = `${sunriseTime ? `ì¼ì¶œ ${sunriseTime}` : ''}${(sunriseTime && sunsetTime) ? ' | ' : ''}${sunsetTime ? `ì¼ëª° ${sunsetTime}` : ''}`;
                html += `<span style="display:flex;align-items:center;gap:4px;"><span style="width:7px;height:7px;background:#ffb74d;border-radius:50%;border:1px solid #fff;flex-shrink:0;"></span><span style="color:#ffb74d;">${sunLabel}</span></span>`;
            }
            tideLegendEl.innerHTML = html;
            tideLegendEl.style.display = 'flex';
        }

        // ì‹œê°„ëŒ€ ì •ë³´ ì—…ë°ì´íŠ¸ (ì°¨íŠ¸ ìœ„ speciesLegend)
        updateSpeciesTimeRanges();
        updateMulddaeSpeciesInfo();
    }

    // ==================== í˜„ì¬ ì‹œê°„ ë§ˆì»¤ 10ë¶„ ìë™ ê°±ì‹  ====================
    let _nowMarkerTimer = null;
    function startNowMarkerTimer() {
        if (_nowMarkerTimer) clearInterval(_nowMarkerTimer);
        _nowMarkerTimer = setInterval(() => {
            if (!tideChart || !window._chartData) return;
            const cd = window._chartData;
            const now = new Date();
            const selDate = document.getElementById('dateInput').value;
            const todayStr = now.getFullYear() + '-' + String(now.getMonth()+1).padStart(2,'0') + '-' + String(now.getDate()).padStart(2,'0');
            if (selDate !== todayStr) return;

            const nowTotal = now.getHours() * 60 + now.getMinutes();
            const snapped = Math.round(nowTotal / 10) * 10;
            const snapHH = String(Math.floor(snapped / 60)).padStart(2, '0');
            const snapMM = String(snapped % 60).padStart(2, '0');
            const nowLabel = snapHH + ':' + snapMM;
            const nowIdx = cd.labels.indexOf(nowLabel);

            const ann = tideChart.options.plugins.annotation.annotations;
            // ì´ì „ ë§ˆì»¤ ì œê±°
            delete ann['now_point'];
            delete ann['now_label'];
            delete ann['now_line'];

            if (nowIdx >= 0) {
                const nowY = cd.predicted[nowIdx] != null ? cd.predicted[nowIdx] : 0;
                ann['now_point'] = {
                    type: 'point', xValue: nowIdx, yValue: nowY,
                    backgroundColor: 'rgba(255,235,59,0.9)',
                    radius: 5, borderColor: '#fff', borderWidth: 1.5,
                };
                const _filteredT = cd.predicted.filter(v => v != null);
                const _yMinT = _filteredT.length > 0 ? Math.min(..._filteredT) : 0;
                ann['now_label'] = {
                    type: 'label', xValue: nowIdx, yValue: _yMinT,
                    xAdjust: 0, yAdjust: 24,
                    content: nowLabel,
                    color: '#ffeb3b',
                    font: { size: 10, weight: 'bold' },
                };
                ann['now_line'] = {
                    type: 'line', xMin: nowIdx, xMax: nowIdx,
                    yMax: nowY,
                    borderColor: 'rgba(255,235,59,0.4)',
                    borderWidth: 1, borderDash: [4, 4],
                };
            }
            tideChart.update('none'); // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ê°±ì‹ 
        }, 10 * 60 * 1000); // 10ë¶„
    }
    startNowMarkerTimer();

    function getCurrentSpeedUnitLabel() {
        return currentSpeedUnit === 'kn' ? 'k/n' : 'cm/s';
    }

    function convertSpeedByUnit(speedCmps, unit = currentSpeedUnit) {
        const v = toFiniteNumber(speedCmps);
        if (v == null) return null;
        if (unit === 'kn') return v / CMPS_PER_KNOT;
        return v;
    }

    function setCurrentViewState(items, el, fldEbbSummary = null, areaSummary = null) {
        currentViewState = {
            items: Array.isArray(items) ? items : [],
            el: el || null,
            fldEbbSummary,
            areaSummary,
        };
    }

    function renderCurrentViews(items, el, fldEbbSummary = null, areaSummary = null) {
        setCurrentViewState(items, el, fldEbbSummary, areaSummary);
        renderCurrentTable(items, el, fldEbbSummary, areaSummary);
        renderCurrentChart(items);
    }

    function toggleCurrentSpeedUnit() {
        currentSpeedUnit = currentSpeedUnit === 'cm/s' ? 'kn' : 'cm/s';
        const chartUnitEl = document.getElementById('chartSpeedUnitLabel');
        if (chartUnitEl) chartUnitEl.textContent = 'ìœ ì† (' + getCurrentSpeedUnitLabel() + ')';
        if (!currentViewState || !currentViewState.el) return;
        renderCurrentViews(
            currentViewState.items,
            currentViewState.el,
            currentViewState.fldEbbSummary,
            currentViewState.areaSummary
        );
    }

    // ==================== 3) ì¡°ë¥˜ (crntFcstTime ì‹œê³„ì—´) ====================
    async function fetchCurrentData() {
        const infoEl = document.getElementById('currentInfo');
        const cStation = getCurrentStation();
        const dateStr = getDateStr();
        const stationCode = getStation();
        if (!cStation) {
            infoEl.innerHTML = '<div class="error-msg">ì´ ì§€ì—­ì—ëŠ” ì¡°ë¥˜ ì˜ˆë³´ì ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            renderCurrentViews([], infoEl);
            renderMulddaeCardFromState();
            return;
        }
        infoEl.innerHTML = '<div class="loading"><div class="spinner"></div><div>ì¡°ë¥˜ ë°ì´í„° ë¡œë”©...</div></div>';

        try {
            requestCurrentFlowStatsPrime(cStation, dateStr, true);
            const firstPageItems = await apiCall('crntFcstTime/GetCrntFcstTimeApiService', {
                obsCode: cStation,
                reqDate: dateStr,
                // crntFcstTimeëŠ” 1í˜ì´ì§€ë‹¹ 300ê±´ ê¸°ì¤€ìœ¼ë¡œ í˜ì´ì§€ë„¤ì´ì…˜í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì•ˆì •ì ì´ë‹¤.
                numOfRows: '300',
                pageNo: '1',
                min: '10'
            });

            let fldEbbSummary = null;
            try {
                const fldEbbItems = await apiCall('crntFcstFldEbb/GetCrntFcstFldEbbApiService', {
                    obsCode: cStation,
                    reqDate: dateStr,
                    numOfRows: '20',
                    pageNo: '1'
                });
                fldEbbSummary = parseFldEbbSummary(fldEbbItems);
            } catch(e) {
                // ì°½/ë‚™ì¡° API ì‹¤íŒ¨ ì‹œ í‘œ/ì°¨íŠ¸ëŠ” ê¸°ë³¸ ë°ì´í„°ë¡œ ê³„ì† í‘œì‹œ
            }

            let areaSummary = null;
            try {
                const geo = getActiveGeoPoint(stationCode);
                if (geo) {
                    const bounds = getKhoaAreaBounds(geo.lat, geo.lon);
                    const t = getKhoaAreaQueryTime(dateStr);
                    const areaRaw = await apiCallRaw('/api/khoa/current-area', {
                        date: dateStr,
                        hour: t.hour,
                        minute: t.minute,
                        minX: bounds.minX,
                        maxX: bounds.maxX,
                        minY: bounds.minY,
                        maxY: bounds.maxY,
                        scale: '400000'
                    });
                    areaSummary = parseKhoaAreaSummary(areaRaw);
                    if (areaSummary) {
                        areaSummary.timeLabel = t.label;
                        areaSummary.areaName = geo.name;
                    }
                }
            } catch(e) {
                // ë©´ì¡°ë¥˜ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì¡°ë¥˜ ì •ë³´ë§Œ í‘œì‹œ
            }

            if (!firstPageItems || firstPageItems.length === 0) {
                infoEl.innerHTML = '<div class="error-msg">ì¡°ë¥˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜ˆë³´ì ì„ í™•ì¸í•´ì£¼ì„¸ìš”.</div>';
                renderCurrentViews([], infoEl, fldEbbSummary, areaSummary);
                renderMulddaeCardFromState();
                return;
            }

            let mergedItems = Array.isArray(firstPageItems) ? [...firstPageItems] : [];
            let timeTaggedItems = mergedItems.map((item) => ({ ...item, __timeLabel: extractCurrentTimeLabel(item) }));
            let withTimeItems = timeTaggedItems.filter((item) => !!item.__timeLabel);
            let timeFiltered = withTimeItems.filter((item) => (
                item.__timeLabel >= '05:00' && item.__timeLabel <= '18:00'
            ));

            // í˜ì´ì§€ 1ì— 05~18ì‹œ êµ¬ê°„ì´ ì—†ìœ¼ë©´ ì¶”ê°€ í˜ì´ì§€ ì¡°íšŒ í›„ ë³‘í•© ì¬ì‹œë„
            if (timeFiltered.length === 0) {
                const extraPages = ['2', '3', '4', '5'];
                const extraResults = await Promise.all(extraPages.map((pageNo) => (
                    apiCall('crntFcstTime/GetCrntFcstTimeApiService', {
                        obsCode: cStation,
                        reqDate: dateStr,
                        numOfRows: '300',
                        pageNo,
                        min: '10'
                    }).catch(() => [])
                )));

                extraResults.forEach((chunk) => {
                    if (Array.isArray(chunk) && chunk.length > 0) mergedItems.push(...chunk);
                });
                mergedItems = dedupeCurrentItems(mergedItems);
                timeTaggedItems = mergedItems.map((item) => ({ ...item, __timeLabel: extractCurrentTimeLabel(item) }));
                withTimeItems = timeTaggedItems.filter((item) => !!item.__timeLabel);
                timeFiltered = withTimeItems.filter((item) => (
                    item.__timeLabel >= '05:00' && item.__timeLabel <= '18:00'
                ));
            }

            const flowSnapshot = buildCurrentFlowSnapshot(mergedItems, cStation, dateStr);
            if (flowSnapshot) {
                setCurrentFlowSnapshot(cStation, dateStr, flowSnapshot);
            }
            if (timeFiltered.length === 0) {
                if (withTimeItems.length === 0) {
                    const fallback = mergedItems.filter((_, idx) => idx % 10 === 0);
                    renderCurrentViews(fallback, infoEl, fldEbbSummary, areaSummary);
                    renderMulddaeCardFromState();
                    return;
                }
                infoEl.innerHTML = '<div class="error-msg">05:00~18:00 ë²”ìœ„ ì¡°ë¥˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                renderCurrentViews([], infoEl, fldEbbSummary, areaSummary);
                renderMulddaeCardFromState();
                return;
            }

            const tenMinuteFiltered = timeFiltered.filter((item) => {
                const time = item.__timeLabel || extractCurrentTimeLabel(item);
                if (!time) return false;
                const mm = parseInt(time.substring(3, 5), 10);
                return Number.isFinite(mm) && (mm % 10 === 0);
            });
            const filtered = tenMinuteFiltered.length > 0
                ? tenMinuteFiltered
                : timeFiltered.filter((_, idx) => idx % 10 === 0);
            renderCurrentViews(filtered, infoEl, fldEbbSummary, areaSummary);
            renderMulddaeCardFromState();
        } catch(e) {
            infoEl.innerHTML = `<div class="error-msg">ì¡°ë¥˜ ì˜¤ë¥˜: ${escapeHTML(e.message)}</div>`;
            renderCurrentViews([], infoEl);
            renderMulddaeCardFromState();
        }
    }

    function getSpeedColor(speed) {
        const s = parseFloat(speed);
        if (s >= 100) return '#ff6b6b';
        if (s >= 50) return '#ffa726';
        if (s >= 20) return '#4fc3f7';
        return '#4ecdc4';
    }

    function renderCurrentTable(items, el, fldEbbSummary = null, areaSummary = null) {
        if (!items || items.length === 0) return;
        const speeds = items.map(i => parseFloat(i.crsp) || 0);
        const maxSpeed = speeds.length > 0 ? Math.max(...speeds, 1) : 1;
        const speedUnitLabel = getCurrentSpeedUnitLabel();
        const fldText = fldEbbSummary && fldEbbSummary.fldTime ? fldEbbSummary.fldTime : '-';
        const ebbText = fldEbbSummary && fldEbbSummary.ebbTime ? fldEbbSummary.ebbTime : '-';
        const fldSpeed = fldEbbSummary && Number.isFinite(fldEbbSummary.fldSpeed) ? convertSpeedByUnit(fldEbbSummary.fldSpeed) : null;
        const ebbSpeed = fldEbbSummary && Number.isFinite(fldEbbSummary.ebbSpeed) ? convertSpeedByUnit(fldEbbSummary.ebbSpeed) : null;
        const fldSpdText = fldSpeed != null ? ` (${fldSpeed.toFixed(1)}${speedUnitLabel})` : '';
        const ebbSpdText = ebbSpeed != null ? ` (${ebbSpeed.toFixed(1)}${speedUnitLabel})` : '';
        const fldEbbLine = (fldEbbSummary && (fldEbbSummary.fldTime || fldEbbSummary.ebbTime))
            ? ` Â· ì°½/ë‚™ì¡° ${fldText}${fldSpdText} / ${ebbText}${ebbSpdText}`
            : '';
        const rawAreaUnit = areaSummary && areaSummary.unit ? areaSummary.unit : '';
        const areaNeedsUnitConvert = currentSpeedUnit === 'kn' && rawAreaUnit === 'cm/s';
        const areaUnit = areaNeedsUnitConvert ? 'k/n' : rawAreaUnit;
        const areaAvg = areaSummary && Number.isFinite(areaSummary.avgSpeed)
            ? (areaNeedsUnitConvert ? convertSpeedByUnit(areaSummary.avgSpeed) : areaSummary.avgSpeed)
            : null;
        const areaMax = areaSummary && Number.isFinite(areaSummary.maxSpeed)
            ? (areaNeedsUnitConvert ? convertSpeedByUnit(areaSummary.maxSpeed) : areaSummary.maxSpeed)
            : null;
        const areaAvgText = areaSummary && Number.isFinite(areaSummary.avgSpeed)
            ? `${areaAvg.toFixed(2)}${areaUnit ? areaUnit : ''}`
            : '-';
        const areaMaxText = areaSummary && Number.isFinite(areaSummary.maxSpeed)
            ? `${areaMax.toFixed(2)}${areaUnit ? areaUnit : ''}`
            : '-';
        const areaDirText = areaSummary && areaSummary.dirText ? ` ${areaSummary.dirText}` : '';
        const areaLine = areaSummary
            ? ` Â· ë©´ì¡°ë¥˜ ${escapeHTML(areaSummary.areaName || '')} ${escapeHTML(areaSummary.timeLabel || '')} í‰ê·  ${areaAvgText} / ìµœëŒ€ ${areaMaxText}${areaDirText} (n=${areaSummary.sampleCount})`
            : '';

        el.innerHTML = `
            <div style="margin-bottom:10px;font-size:0.82em;color:var(--muted);">
                ì˜ˆë³´ì : <strong style="color:var(--text)">${escapeHTML(items[0]?.obsvtrNm || '-')}</strong> Â·
                ì´ ${items.length}ê±´ (10ë¶„ ê°„ê²©)${fldEbbLine}${areaLine}
            </div>
            <div style="max-height:400px;overflow-y:auto;">
            <table class="current-table">
                <thead><tr><th>ì‹œê°„</th><th>ìœ í–¥</th><th class="current-speed-col"><button type="button" class="current-unit-toggle-btn" onclick="toggleCurrentSpeedUnit()" title="í´ë¦­í•´ì„œ cm/sì™€ k/n ë‹¨ìœ„ë¥¼ ì „í™˜" aria-label="ìœ ì† ë‹¨ìœ„ ì „í™˜"><span>ìœ ì† (${speedUnitLabel})</span><span class="unit-icon">â‡„</span><span class="unit-hint">í´ë¦­ ì „í™˜</span></button></th><th>ì„¸ê¸°</th></tr></thead>
                <tbody>
                    ${items.map(item => {
                        const time = item.__timeLabel || extractCurrentTimeLabel(item) || '-';
                        const speed = parseFloat(item.crsp) || 0;
                        const speedDisplay = convertSpeedByUnit(speed);
                        const pct = (speed / maxSpeed) * 100;
                        const color = getSpeedColor(speed);
                        return `<tr>
                            <td>${time}</td>
                            <td class="current-dir-col" style="color:${color};">${escapeHTML(item.crdir || '-')}</td>
                            <td class="current-speed-col">${speedDisplay.toFixed(1)}</td>
                            <td style="min-width:100px;"><div class="speed-bar"><div class="speed-bar-fill" style="width:${pct}%;background:${color};"></div></div></td>
                        </tr>`;
                    }).join('')}
                </tbody>
            </table>
            </div>`;
    }

    function renderCurrentChart(items) {
        const canvasEl = document.getElementById('currentChart');
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        if (currentChart) currentChart.destroy();
        if (!items || items.length === 0) { currentChart = null; return; }

        const labels = items.map(i => i.__timeLabel || extractCurrentTimeLabel(i) || '-');
        const rawSpeeds = items.map(i => parseFloat(i.crsp) || 0);
        const speeds = rawSpeeds.map((v) => convertSpeedByUnit(v));
        const speedUnitLabel = getCurrentSpeedUnitLabel();
        const chartUnitEl = document.getElementById('chartSpeedUnitLabel');
        if (chartUnitEl) chartUnitEl.textContent = 'ìœ ì† (' + speedUnitLabel + ')';

        const gradient = ctx.createLinearGradient(0, 0, 0, 320);
        gradient.addColorStop(0, 'rgba(0,229,255,0.3)');
        gradient.addColorStop(1, 'rgba(0,229,255,0.02)');

        // í˜„ì¬ ì‹œê°„ ì¸ë±ìŠ¤ ê³„ì‚°
        let nowIdx = -1;
        const _today = new Date();
        const _selDate = document.getElementById('dateInput').value;
        const _todayStr = _today.getFullYear() + '-' + String(_today.getMonth()+1).padStart(2,'0') + '-' + String(_today.getDate()).padStart(2,'0');
        if (_selDate === _todayStr && labels.length > 0) {
            const nowH = _today.getHours(), nowM = _today.getMinutes();
            const snapped = Math.round((nowH * 60 + nowM) / 10) * 10;
            const snapHH = String(Math.floor(snapped / 60)).padStart(2, '0');
            const snapMM = String(snapped % 60).padStart(2, '0');
            nowIdx = labels.indexOf(snapHH + ':' + snapMM);
        }

        // annotation ê°ì²´ ìƒì„±
        const annotations = {};
        if (nowIdx >= 0 && speeds[nowIdx] != null) {
            const nowSpeed = speeds[nowIdx];
            // ë…¸ë€ í¬ì¸íŠ¸
            annotations['now_point'] = {
                type: 'point', xValue: nowIdx, yValue: nowSpeed,
                backgroundColor: 'rgba(255,235,59,0.9)',
                radius: 5, borderColor: '#fff', borderWidth: 1.5,
            };
            // ì‹œê° ë¼ë²¨ (í•˜ë‹¨)
            annotations['now_label'] = {
                type: 'label', xValue: nowIdx,
                yValue: 0,
                yAdjust: 6,
                content: labels[nowIdx],
                color: '#ffeb3b',
                font: { size: 10, weight: 'bold' },
            };
            // ìˆ˜í‰ ì ì„ : í˜„ì¬ìœ„ì¹˜ â†’ ì¢Œì¸¡ Yì¶•ê¹Œì§€
            annotations['now_hline'] = {
                type: 'line',
                xMin: 0, xMax: nowIdx,
                yMin: nowSpeed, yMax: nowSpeed,
                borderColor: 'rgba(0,229,255,0.35)',
                borderWidth: 1.5, borderDash: [5, 4],
            };
            // ê¸°ì¤€ê°’ ë¼ë²¨ (ì¢Œì¸¡ Yì¶• ë)
            annotations['now_hline_val'] = {
                type: 'label',
                xValue: 0, yValue: nowSpeed,
                xAdjust: -5,
                content: '(' + nowSpeed.toFixed(1) + ')',
                color: '#00e5ff',
                font: { size: 9, weight: 'bold' },
                backgroundColor: 'rgba(17,29,53,0.85)',
                padding: { top: 2, bottom: 2, left: 4, right: 4 },
                borderRadius: 3,
                position: { x: 'start' },
            };
        }

        // ìˆ˜ì§ ì ì„  í”ŒëŸ¬ê·¸ì¸ (í˜„ì¬ ìœ„ì¹˜ â†’ ê³¡ì„ ê¹Œì§€)
        const nowLinePlugin = {
            id: 'currentNowLine',
            afterDraw(chart) {
                if (nowIdx < 0 || speeds[nowIdx] == null) return;
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                const x = xScale.getPixelForValue(nowIdx);
                const topY = yScale.getPixelForValue(speeds[nowIdx]);
                const bottomY = chart.chartArea.bottom;
                const c = chart.ctx;
                c.save();
                c.beginPath();
                c.setLineDash([4, 4]);
                c.strokeStyle = 'rgba(255,235,59,0.5)';
                c.lineWidth = 1.2;
                c.moveTo(x, bottomY);
                c.lineTo(x, topY);
                c.stroke();
                c.restore();
            }
        };

        currentChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [{
                    label: `ìœ ì† (${speedUnitLabel})`, data: speeds,
                    borderColor: '#00e5ff', backgroundColor: gradient,
                    borderWidth: 2, fill: true, tension: 0.4,
                    pointRadius: 0, pointHoverRadius: 0,
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                layout: { padding: { top: 8, left: 0, right: 0 } },
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false },
                    annotation: { clip: false, annotations }
                },
                scales: {
                    x: { ticks: { color: '#7a8ba3', maxTicksLimit: 12, font: { size: 11 } }, grid: { color: 'rgba(255,255,255,0.04)' } },
                    y: { ticks: { color: '#7a8ba3', font: { size: 11 }, callback: v => v + '', padding: 0 }, grid: { color: 'rgba(255,255,255,0.06)' } }
                }
            },
            plugins: [nowLinePlugin]
        });
    }

    // ==================== ì¡°ìœ„-ìœ ì† ë³µí•© ê·¸ë˜í”„ ====================
    function renderCombinedChart() {
        const canvasEl = document.getElementById('combinedChart');
        if (!canvasEl) return;
        const ctx = canvasEl.getContext('2d');
        if (combinedChart) combinedChart.destroy();

        const chartData = window._chartData;
        const currentData = currentViewState && currentViewState.items ? currentViewState.items : [];
        const infoEl = document.getElementById('combinedChartInfo');

        if ((!chartData || !chartData.labels || chartData.labels.length === 0) && currentData.length === 0) {
            combinedChart = null;
            if (infoEl) infoEl.textContent = 'ì¡°ìœ„ ë˜ëŠ” ìœ ì† ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ê´€ì¸¡ì†Œì™€ ë‚ ì§œë¥¼ ì„ íƒ í›„ ì¡°íšŒí•˜ì„¸ìš”.';
            return;
        }

        // ì¡°ìœ„ ë°ì´í„° ì¤€ë¹„
        const tideLabels = chartData && chartData.labels ? chartData.labels : [];
        const tidePredicted = chartData && chartData.predicted ? chartData.predicted : [];

        // ìœ ì† ë°ì´í„° ì¤€ë¹„
        const currentLabels = currentData.map(i => i.__timeLabel || extractCurrentTimeLabel(i) || '-');
        const currentSpeeds = currentData.map(i => parseFloat(i.crsp) || 0);

        // ê³µí†µ ì‹œê°„ ë¼ë²¨ ìƒì„± (í•©ì§‘í•©, ì •ë ¬)
        const allLabelsSet = new Set([...tideLabels, ...currentLabels]);
        const allLabels = Array.from(allLabelsSet).sort();

        if (allLabels.length === 0) {
            combinedChart = null;
            if (infoEl) infoEl.textContent = 'í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
            return;
        }

        // ì¡°ìœ„ ë°ì´í„°ë¥¼ ê³µí†µ ë¼ë²¨ì— ë§¤í•‘
        const tideMap = {};
        tideLabels.forEach((lbl, i) => { tideMap[lbl] = tidePredicted[i]; });
        const tideValues = allLabels.map(lbl => tideMap[lbl] != null ? tideMap[lbl] : null);

        // ìœ ì† ë°ì´í„°ë¥¼ ê³µí†µ ë¼ë²¨ì— ë§¤í•‘
        const speedMap = {};
        currentLabels.forEach((lbl, i) => { speedMap[lbl] = currentSpeeds[i]; });
        const speedValues = allLabels.map(lbl => speedMap[lbl] != null ? speedMap[lbl] : null);

        const hasTide = tideValues.some(v => v != null);
        const hasSpeed = speedValues.some(v => v != null);

        // Yì¶• ë²”ìœ„ ê³„ì‚° (datasetsë³´ë‹¤ ë¨¼ì €)
        const tideValid = tideValues.filter(v => v != null);
        const speedValid = speedValues.filter(v => v != null);
        const tideMin = tideValid.length > 0 ? Math.min(...tideValid) : 0;
        const tideMax = tideValid.length > 0 ? Math.max(...tideValid) : 100;
        const speedMax = speedValid.length > 0 ? Math.max(...speedValid) : 50;

        // í˜„ì¬ ì‹œê°„ ì¸ë±ìŠ¤ ê³„ì‚° (segment ìƒ‰ìƒ ë¶„ë¦¬ìš©, datasets ìƒì„± ì „ì— í•„ìš”)
        let nowIdx = -1;
        const _today = new Date();
        const _selDate = document.getElementById('dateInput').value;
        const _todayStr = _today.getFullYear() + '-' + String(_today.getMonth()+1).padStart(2,'0') + '-' + String(_today.getDate()).padStart(2,'0');
        if (_selDate === _todayStr && allLabels.length > 0) {
            const nowH = _today.getHours(), nowM = _today.getMinutes();
            const snapped = Math.round((nowH * 60 + nowM) / 10) * 10;
            const snapHH = String(Math.floor(snapped / 60)).padStart(2, '0');
            const snapMM = String(snapped % 60).padStart(2, '0');
            nowIdx = allLabels.indexOf(snapHH + ':' + snapMM);
        }

        // ì¡°ìœ„: area fill ê·¸ë¼ë””ì–¸íŠ¸ (ë¬¼ í‘œí˜„)
        const tideGrad = ctx.createLinearGradient(0, 0, 0, 380);
        tideGrad.addColorStop(0, 'rgba(56,189,248,0.40)');
        tideGrad.addColorStop(0.5, 'rgba(56,189,248,0.12)');
        tideGrad.addColorStop(1, 'rgba(56,189,248,0.0)');

        // ì˜ˆì¸¡ êµ¬ê°„ íšŒìƒ‰ ê·¸ë¼ë””ì–¸íŠ¸
        const grayGrad = ctx.createLinearGradient(0, 0, 0, 380);
        grayGrad.addColorStop(0, 'rgba(148,163,184,0.12)');
        grayGrad.addColorStop(0.5, 'rgba(148,163,184,0.04)');
        grayGrad.addColorStop(1, 'rgba(148,163,184,0.0)');

        const datasets = [];
        // ì¡°ìœ„: area fill (ë’¤ìª½ â€” ë¬¼ ë°°ê²½)
        if (hasTide) {
            datasets.push({
                label: 'ì¡°ìœ„ (cm)',
                data: tideValues,
                borderColor: '#38bdf8',
                backgroundColor: tideGrad,
                borderWidth: 2.5, fill: true, tension: 0.4, cubicInterpolationMode: 'monotone',
                pointRadius: 0, pointHoverRadius: 5, pointHoverBackgroundColor: '#38bdf8', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2,
                yAxisID: 'yTide',
                order: 2,
                segment: {
                    borderColor: ctx => nowIdx >= 0 && ctx.p1DataIndex > nowIdx ? 'rgba(148,163,184,0.5)' : undefined,
                    backgroundColor: ctx => nowIdx >= 0 && ctx.p1DataIndex > nowIdx ? grayGrad : undefined,
                },
            });
        }
        // ìœ ì†: ë¼ì¸ (ì•ìª½ â€” fill ì—†ì´ ê¹”ë”í•œ ì„ )
        if (hasSpeed) {
            datasets.push({
                label: 'ìœ ì† (cm/s)',
                data: speedValues,
                borderColor: '#34d399',
                backgroundColor: 'transparent',
                borderWidth: 2, fill: false, tension: 0.4,
                pointRadius: 0, pointHoverRadius: 5, pointHoverBackgroundColor: '#34d399', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2,
                yAxisID: 'ySpeed',
                order: 1,
                segment: {
                    borderColor: ctx => nowIdx >= 0 && ctx.p1DataIndex > nowIdx ? 'rgba(148,163,184,0.45)' : undefined,
                },
            });
        }

        const scales = {
            x: {
                ticks: { color: '#94a3b8', maxTicksLimit: 14, font: { size: 10 }, maxRotation: 0, callback: function(val) { const lbl = this.getLabelForValue(val); return lbl && lbl.endsWith(':00') ? lbl : null; } },
                grid: { color: 'rgba(255,255,255,0.05)' },
                border: { color: 'rgba(255,255,255,0.08)' },
            },
        };
        if (hasTide) {
            scales.yTide = {
                type: 'linear', position: 'left', display: true,
                min: Math.min(0, Math.floor(tideMin / 100) * 100),
                max: Math.max(100, Math.ceil(tideMax / 100) * 100),
                ticks: { stepSize: 100, color: '#38bdf8', font: { size: 10 }, callback: v => v + '', padding: 0 },
                grid: { color: 'rgba(56,189,248,0.07)' },
                border: { display: false },
                title: { display: false },
            };
        }
        if (hasSpeed) {
            const rawSpeedMax = Math.ceil(speedMax / 20) * 20 + 20;
            const speedStep = rawSpeedMax <= 60 ? 10 : rawSpeedMax <= 120 ? 20 : rawSpeedMax <= 300 ? 50 : 100;
            const speedAxisMax = Math.ceil(rawSpeedMax / speedStep) * speedStep;
            scales.ySpeed = {
                type: 'linear', position: 'right', display: true,
                min: 0,
                max: speedAxisMax,
                ticks: { stepSize: speedStep, color: '#34d399', font: { size: 10 }, callback: v => v + '', padding: 0 },
                grid: { drawOnChartArea: false },
                border: { display: false },
                title: { display: false },
            };
        }

        // í˜„ì¬ ì‹œê°„ ë§ˆì»¤ (nowIdxëŠ” ìƒë‹¨ì—ì„œ ì´ë¯¸ ê³„ì‚°ë¨)
        const annotations = {};
        if (nowIdx >= 0) {
            const nowLabel = allLabels[nowIdx];
            const nowTideY = tideValues[nowIdx] != null ? tideValues[nowIdx] : null;
            if (hasTide && nowTideY != null) {
                annotations['now_point'] = {
                    type: 'point', xValue: nowIdx, yValue: nowTideY,
                    backgroundColor: 'rgba(255,235,59,0.9)',
                    radius: 5, borderColor: '#fff', borderWidth: 1.5,
                    yScaleID: 'yTide',
                };
            }
            const _tValid = tideValid.length > 0 ? Math.min(...tideValid) : 0;
            annotations['now_label'] = {
                type: 'label', xValue: nowIdx,
                yValue: hasTide ? _tValid : 0,
                yAdjust: 24,
                content: nowLabel,
                color: '#ffeb3b',
                font: { size: 10, weight: 'bold' },
                ...(hasTide ? { yScaleID: 'yTide' } : {}),
            };
            // ìœ ì† ê°’ (ìˆ˜ì§ì„  ë§ˆê°ì  ê³„ì‚°ìš©)
            const nowSpeedRaw = speedValues[nowIdx] != null ? speedValues[nowIdx] : null;
            // ìˆ˜ì§ ì ì„ ì€ ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸(nowLinePlugin)ìœ¼ë¡œ ê·¸ë¦¼ (ì¡°ìœ„~ìœ ì† í¬ì¸íŠ¸ ì‚¬ì´ë§Œ)
            // ìœ ì† ê³¡ì„  ìœ„ í¬ì¸íŠ¸
            if (hasSpeed && nowSpeedRaw != null) {
                annotations['now_point_speed'] = {
                    type: 'point', xValue: nowIdx, yValue: nowSpeedRaw,
                    backgroundColor: 'rgba(255,235,59,0.9)',
                    radius: 5, borderColor: '#fff', borderWidth: 1.5,
                    yScaleID: 'ySpeed',
                };
            }
            // ì¡°ìœ„ ìˆ˜í‰ ì ì„ : í˜„ì¬ìœ„ì¹˜ â†’ ì™¼ìª½(ì¡°ìœ„ì¶•)ê¹Œì§€ë§Œ (ì¡°ìœ„ ìƒ‰ìƒ)
            if (hasTide && nowTideY != null) {
                annotations['now_hline'] = {
                    type: 'line',
                    xMin: 0, xMax: nowIdx,
                    yMin: nowTideY, yMax: nowTideY,
                    yScaleID: 'yTide',
                    borderColor: 'rgba(56,189,248,0.35)',
                    borderWidth: 1.5, borderDash: [5, 4],
                };
                // ì¡°ìœ„ ê¸°ì¤€ê°’ ë¼ë²¨ (ì¢Œì¸¡ Yì¶• ë)
                annotations['now_hline_val'] = {
                    type: 'label',
                    xValue: 0,
                    yValue: nowTideY,
                    yScaleID: 'yTide',
                    xAdjust: -5,
                    content: '(' + nowTideY.toFixed(0) + ')',
                    color: '#38bdf8',
                    font: { size: 8, weight: 'bold' },
                    backgroundColor: 'rgba(17,29,53,0.85)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 },
                    borderRadius: 3,
                    position: { x: 'start' },
                };
            }
            // ìœ ì† ìˆ˜í‰ ì ì„ : í˜„ì¬ìœ„ì¹˜ â†’ ì˜¤ë¥¸ìª½(ìœ ì†ì¶•)ê¹Œì§€ë§Œ (ìœ ì† ìƒ‰ìƒ)
            if (hasSpeed && nowSpeedRaw != null) {
                annotations['now_hline_speed'] = {
                    type: 'line',
                    xMin: nowIdx, xMax: allLabels.length - 1,
                    yMin: nowSpeedRaw, yMax: nowSpeedRaw,
                    yScaleID: 'ySpeed',
                    borderColor: 'rgba(52,211,153,0.35)',
                    borderWidth: 1.5, borderDash: [5, 4],
                };
                // ìœ ì† ê¸°ì¤€ê°’ ë¼ë²¨ (ìš°ì¸¡ Yì¶• ë)
                annotations['now_hline_speed_val'] = {
                    type: 'label',
                    xValue: allLabels.length - 1,
                    yValue: nowSpeedRaw,
                    yScaleID: 'ySpeed',
                    xAdjust: 5,
                    content: '(' + nowSpeedRaw.toFixed(0) + ')',
                    color: '#34d399',
                    font: { size: 8, weight: 'bold' },
                    backgroundColor: 'rgba(17,29,53,0.85)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 },
                    borderRadius: 3,
                    position: { x: 'end' },
                };
            }
            const nowSpeedY = speedValues[nowIdx] != null ? speedValues[nowIdx] : null;
        }

        // ë²”ë¡€ì— ì˜ˆì¸¡ êµ¬ê°„ í‘œê¸° ì¶”ê°€ë¥¼ ìœ„í•œ í”Œë˜ê·¸
        const hasNowSplit = nowIdx >= 0;

        // í˜„ì¬ ì‹œê°„ ìˆ˜ì§ ì ì„  í”ŒëŸ¬ê·¸ì¸ (ì¡°ìœ„ í¬ì¸íŠ¸ ~ ìœ ì† í¬ì¸íŠ¸ ì‚¬ì´ë§Œ)
        const _nowIdx = nowIdx;
        const _nowTideY = (nowIdx >= 0 && tideValues[nowIdx] != null) ? tideValues[nowIdx] : null;
        const _nowSpeedY = (nowIdx >= 0 && speedValues[nowIdx] != null) ? speedValues[nowIdx] : null;
        const nowLinePlugin = {
            id: 'combinedNowLine',
            afterDraw(chart) {
                if (_nowIdx < 0) return;
                const xScale = chart.scales.x;
                const x = xScale.getPixelForValue(_nowIdx);
                const { bottom } = chart.chartArea;
                const c = chart.ctx;
                // ìƒë‹¨ ëì : ìœ ì† í¬ì¸íŠ¸ â†’ ì¡°ìœ„ í¬ì¸íŠ¸ â†’ ì°¨íŠ¸ í•˜ë‹¨ (fallback)
                let topY = bottom;
                if (_nowSpeedY != null && chart.scales.ySpeed) {
                    topY = chart.scales.ySpeed.getPixelForValue(_nowSpeedY);
                } else if (_nowTideY != null && chart.scales.yTide) {
                    topY = chart.scales.yTide.getPixelForValue(_nowTideY);
                }
                c.save();
                c.beginPath();
                c.moveTo(x, bottom);
                c.lineTo(x, topY);
                c.lineWidth = 1;
                c.strokeStyle = 'rgba(255,235,59,0.4)';
                c.setLineDash([4, 4]);
                c.stroke();
                c.restore();
            }
        };

        // í¬ë¡œìŠ¤í—¤ì–´ í”ŒëŸ¬ê·¸ì¸ (í˜¸ë²„ ì‹œ ìˆ˜ì§ì„ )
        const crosshairPlugin = {
            id: 'combinedCrosshair',
            afterDraw(chart) {
                if (chart.tooltip && chart.tooltip._active && chart.tooltip._active.length) {
                    const x = chart.tooltip._active[0].element.x;
                    const { top, bottom } = chart.chartArea;
                    const c = chart.ctx;
                    c.save();
                    c.beginPath();
                    c.moveTo(x, top);
                    c.lineTo(x, bottom);
                    c.lineWidth = 1;
                    c.strokeStyle = 'rgba(255,255,255,0.15)';
                    c.setLineDash([4, 3]);
                    c.stroke();
                    c.restore();
                }
            }
        };

        combinedChart = new Chart(ctx, {
            type: 'line',
            data: { labels: allLabels, datasets },
            plugins: [nowLinePlugin, crosshairPlugin],
            options: {
                responsive: true, maintainAspectRatio: false,
                layout: { padding: { top: 10, right: 0, bottom: 8, left: 0 } },
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(10,22,40,0.92)',
                        titleColor: '#e2e8f0', titleFont: { size: 12, weight: '600' },
                        bodyColor: '#94a3b8', bodyFont: { size: 12 },
                        borderColor: 'rgba(255,255,255,0.08)', borderWidth: 1,
                        padding: { top: 10, bottom: 10, left: 14, right: 14 },
                        cornerRadius: 8,
                        displayColors: true,
                        boxWidth: 10, boxHeight: 10, boxPadding: 4,
                        callbacks: {
                            title: function(items) { return items[0] ? items[0].label : ''; },
                            label: function(c) {
                                if (c.parsed.y == null) return null;
                                if (c.dataset.yAxisID === 'yTide') return '  ì¡°ìœ„  ' + c.parsed.y.toFixed(1) + ' cm';
                                if (c.dataset.yAxisID === 'ySpeed') return '  ìœ ì†  ' + c.parsed.y.toFixed(1) + ' cm/s';
                                return c.dataset.label + ': ' + c.parsed.y;
                            },
                            labelColor: function(c) {
                                if (c.dataset.yAxisID === 'yTide') return { borderColor: '#38bdf8', backgroundColor: '#38bdf8', borderRadius: 2 };
                                return { borderColor: '#34d399', backgroundColor: '#34d399', borderRadius: 2 };
                            }
                        }
                    },
                    annotation: { clip: false, drawTime: 'afterDraw', annotations }
                },
                scales
            }
        });

        // ë²”ë¡€ í‘œì‹œ
        const legendEl = document.getElementById('combinedChartLegend');
        if (legendEl) {
            let html = '';
            if (hasTide) html += '<span style="display:inline-flex;align-items:center;gap:5px;"><span style="width:20px;height:3px;background:#38bdf8;border-radius:2px;"></span><span style="color:#38bdf8;font-weight:500;">ì¡°ìœ„ (cm)</span></span>';
            if (hasSpeed) html += '<span style="display:inline-flex;align-items:center;gap:5px;"><span style="width:20px;height:2px;background:#34d399;border-radius:2px;"></span><span style="color:#34d399;font-weight:500;">ìœ ì† (cm/s)</span></span>';
            if (annotations['now_point'] || annotations['now_line']) html += '<span style="display:inline-flex;align-items:center;gap:5px;"><span style="width:8px;height:8px;background:#ffeb3b;border-radius:50%;border:1px solid #fff;flex-shrink:0;"></span><span style="color:#ffeb3b;font-weight:500;">í˜„ì¬ ìœ„ì¹˜</span></span>';
            if (hasNowSplit) html += '<span style="display:inline-flex;align-items:center;gap:5px;"><span style="width:20px;height:2px;background:rgba(148,163,184,0.5);border-radius:2px;"></span><span style="color:#94a3b8;font-weight:500;">ì˜ˆì¸¡</span></span>';
            legendEl.innerHTML = html;
        }

        // ì •ë³´ í…ìŠ¤íŠ¸
        if (infoEl) {
            const parts = [];
            if (!hasTide) parts.push('ì¡°ìœ„ ë°ì´í„° ì—†ìŒ');
            if (!hasSpeed) parts.push('ìœ ì† ë°ì´í„° ì—†ìŒ');
            infoEl.textContent = parts.length > 0 ? 'â€» ' + parts.join(', ') + ' â€” ì¡°ìœ„ ê´€ì¸¡ì†Œì™€ ì¡°ë¥˜ ì˜ˆë³´ì ì„ í™•ì¸í•´ì£¼ì„¸ìš”.' : '';
        }
    }
    </script>
</body>
</html>
